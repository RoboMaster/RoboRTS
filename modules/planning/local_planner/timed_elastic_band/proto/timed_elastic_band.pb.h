// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timed_elastic_band.proto

#ifndef PROTOBUF_timed_5felastic_5fband_2eproto__INCLUDED
#define PROTOBUF_timed_5felastic_5fband_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rrts {
namespace planning {
namespace local_planner {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

class FrameID;
class Point2D;
class Trajectory;
class FootprintModel;
class Robot;
class GoalTolerance;
class Obstacles;
class Optimization;
class HomotopyClassPlanner;
class Recovery;
class Config;

enum FootprintModel_FootprintType {
  FootprintModel_FootprintType_POINT = 0,
  FootprintModel_FootprintType_CIRCULAR = 1,
  FootprintModel_FootprintType_TWOCIRCLES = 2,
  FootprintModel_FootprintType_LINE = 3,
  FootprintModel_FootprintType_POLYGON = 4
};
bool FootprintModel_FootprintType_IsValid(int value);
const FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MIN = FootprintModel_FootprintType_POINT;
const FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MAX = FootprintModel_FootprintType_POLYGON;
const int FootprintModel_FootprintType_FootprintType_ARRAYSIZE = FootprintModel_FootprintType_FootprintType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FootprintModel_FootprintType_descriptor();
inline const ::std::string& FootprintModel_FootprintType_Name(FootprintModel_FootprintType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FootprintModel_FootprintType_descriptor(), value);
}
inline bool FootprintModel_FootprintType_Parse(
    const ::std::string& name, FootprintModel_FootprintType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FootprintModel_FootprintType>(
    FootprintModel_FootprintType_descriptor(), name, value);
}
// ===================================================================

class FrameID : public ::google::protobuf::Message {
 public:
  FrameID();
  virtual ~FrameID();

  FrameID(const FrameID& from);

  inline FrameID& operator=(const FrameID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameID& default_instance();

  void Swap(FrameID* other);

  // implements Message ----------------------------------------------

  FrameID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameID& from);
  void MergeFrom(const FrameID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string odom_frame = 1;
  inline bool has_odom_frame() const;
  inline void clear_odom_frame();
  static const int kOdomFrameFieldNumber = 1;
  inline const ::std::string& odom_frame() const;
  inline void set_odom_frame(const ::std::string& value);
  inline void set_odom_frame(const char* value);
  inline void set_odom_frame(const char* value, size_t size);
  inline ::std::string* mutable_odom_frame();
  inline ::std::string* release_odom_frame();
  inline void set_allocated_odom_frame(::std::string* odom_frame);

  // optional string map_frame = 2;
  inline bool has_map_frame() const;
  inline void clear_map_frame();
  static const int kMapFrameFieldNumber = 2;
  inline const ::std::string& map_frame() const;
  inline void set_map_frame(const ::std::string& value);
  inline void set_map_frame(const char* value);
  inline void set_map_frame(const char* value, size_t size);
  inline ::std::string* mutable_map_frame();
  inline ::std::string* release_map_frame();
  inline void set_allocated_map_frame(::std::string* map_frame);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.FrameID)
 private:
  inline void set_has_odom_frame();
  inline void clear_has_odom_frame();
  inline void set_has_map_frame();
  inline void clear_has_map_frame();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* odom_frame_;
  ::std::string* map_frame_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static FrameID* default_instance_;
};
// -------------------------------------------------------------------

class Point2D : public ::google::protobuf::Message {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2D& default_instance();

  void Swap(Point2D* other);

  // implements Message ----------------------------------------------

  Point2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Point2D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Point2D* default_instance_;
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  void Swap(Trajectory* other);

  // implements Message ----------------------------------------------

  Trajectory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool teb_autosize = 1;
  inline bool has_teb_autosize() const;
  inline void clear_teb_autosize();
  static const int kTebAutosizeFieldNumber = 1;
  inline bool teb_autosize() const;
  inline void set_teb_autosize(bool value);

  // optional float dt_ref = 2;
  inline bool has_dt_ref() const;
  inline void clear_dt_ref();
  static const int kDtRefFieldNumber = 2;
  inline float dt_ref() const;
  inline void set_dt_ref(float value);

  // optional float dt_hysteresis = 3;
  inline bool has_dt_hysteresis() const;
  inline void clear_dt_hysteresis();
  static const int kDtHysteresisFieldNumber = 3;
  inline float dt_hysteresis() const;
  inline void set_dt_hysteresis(float value);

  // optional bool global_plan_overwrite_orientation = 4;
  inline bool has_global_plan_overwrite_orientation() const;
  inline void clear_global_plan_overwrite_orientation();
  static const int kGlobalPlanOverwriteOrientationFieldNumber = 4;
  inline bool global_plan_overwrite_orientation() const;
  inline void set_global_plan_overwrite_orientation(bool value);

  // optional bool allow_init_with_backwards_motion = 5;
  inline bool has_allow_init_with_backwards_motion() const;
  inline void clear_allow_init_with_backwards_motion();
  static const int kAllowInitWithBackwardsMotionFieldNumber = 5;
  inline bool allow_init_with_backwards_motion() const;
  inline void set_allow_init_with_backwards_motion(bool value);

  // optional float global_plan_viapoint_sep = 6;
  inline bool has_global_plan_viapoint_sep() const;
  inline void clear_global_plan_viapoint_sep();
  static const int kGlobalPlanViapointSepFieldNumber = 6;
  inline float global_plan_viapoint_sep() const;
  inline void set_global_plan_viapoint_sep(float value);

  // optional bool via_points_ordered = 7;
  inline bool has_via_points_ordered() const;
  inline void clear_via_points_ordered();
  static const int kViaPointsOrderedFieldNumber = 7;
  inline bool via_points_ordered() const;
  inline void set_via_points_ordered(bool value);

  // optional float max_global_plan_lookahead_dist = 8;
  inline bool has_max_global_plan_lookahead_dist() const;
  inline void clear_max_global_plan_lookahead_dist();
  static const int kMaxGlobalPlanLookaheadDistFieldNumber = 8;
  inline float max_global_plan_lookahead_dist() const;
  inline void set_max_global_plan_lookahead_dist(float value);

  // optional bool exact_arc_length = 9;
  inline bool has_exact_arc_length() const;
  inline void clear_exact_arc_length();
  static const int kExactArcLengthFieldNumber = 9;
  inline bool exact_arc_length() const;
  inline void set_exact_arc_length(bool value);

  // optional float force_reinit_new_goal_dist = 10;
  inline bool has_force_reinit_new_goal_dist() const;
  inline void clear_force_reinit_new_goal_dist();
  static const int kForceReinitNewGoalDistFieldNumber = 10;
  inline float force_reinit_new_goal_dist() const;
  inline void set_force_reinit_new_goal_dist(float value);

  // optional int64 feasibility_check_no_poses = 11;
  inline bool has_feasibility_check_no_poses() const;
  inline void clear_feasibility_check_no_poses();
  static const int kFeasibilityCheckNoPosesFieldNumber = 11;
  inline ::google::protobuf::int64 feasibility_check_no_poses() const;
  inline void set_feasibility_check_no_poses(::google::protobuf::int64 value);

  // optional bool publish_feedback = 12;
  inline bool has_publish_feedback() const;
  inline void clear_publish_feedback();
  static const int kPublishFeedbackFieldNumber = 12;
  inline bool publish_feedback() const;
  inline void set_publish_feedback(bool value);

  // optional int64 min_samples = 13;
  inline bool has_min_samples() const;
  inline void clear_min_samples();
  static const int kMinSamplesFieldNumber = 13;
  inline ::google::protobuf::int64 min_samples() const;
  inline void set_min_samples(::google::protobuf::int64 value);

  // optional int64 max_samples = 14;
  inline bool has_max_samples() const;
  inline void clear_max_samples();
  static const int kMaxSamplesFieldNumber = 14;
  inline ::google::protobuf::int64 max_samples() const;
  inline void set_max_samples(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Trajectory)
 private:
  inline void set_has_teb_autosize();
  inline void clear_has_teb_autosize();
  inline void set_has_dt_ref();
  inline void clear_has_dt_ref();
  inline void set_has_dt_hysteresis();
  inline void clear_has_dt_hysteresis();
  inline void set_has_global_plan_overwrite_orientation();
  inline void clear_has_global_plan_overwrite_orientation();
  inline void set_has_allow_init_with_backwards_motion();
  inline void clear_has_allow_init_with_backwards_motion();
  inline void set_has_global_plan_viapoint_sep();
  inline void clear_has_global_plan_viapoint_sep();
  inline void set_has_via_points_ordered();
  inline void clear_has_via_points_ordered();
  inline void set_has_max_global_plan_lookahead_dist();
  inline void clear_has_max_global_plan_lookahead_dist();
  inline void set_has_exact_arc_length();
  inline void clear_has_exact_arc_length();
  inline void set_has_force_reinit_new_goal_dist();
  inline void clear_has_force_reinit_new_goal_dist();
  inline void set_has_feasibility_check_no_poses();
  inline void clear_has_feasibility_check_no_poses();
  inline void set_has_publish_feedback();
  inline void clear_has_publish_feedback();
  inline void set_has_min_samples();
  inline void clear_has_min_samples();
  inline void set_has_max_samples();
  inline void clear_has_max_samples();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float dt_ref_;
  float dt_hysteresis_;
  bool teb_autosize_;
  bool global_plan_overwrite_orientation_;
  bool allow_init_with_backwards_motion_;
  bool via_points_ordered_;
  float global_plan_viapoint_sep_;
  float max_global_plan_lookahead_dist_;
  float force_reinit_new_goal_dist_;
  ::google::protobuf::int64 feasibility_check_no_poses_;
  ::google::protobuf::int64 min_samples_;
  ::google::protobuf::int64 max_samples_;
  bool exact_arc_length_;
  bool publish_feedback_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Trajectory* default_instance_;
};
// -------------------------------------------------------------------

class FootprintModel : public ::google::protobuf::Message {
 public:
  FootprintModel();
  virtual ~FootprintModel();

  FootprintModel(const FootprintModel& from);

  inline FootprintModel& operator=(const FootprintModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FootprintModel& default_instance();

  void Swap(FootprintModel* other);

  // implements Message ----------------------------------------------

  FootprintModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FootprintModel& from);
  void MergeFrom(const FootprintModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FootprintModel_FootprintType FootprintType;
  static const FootprintType POINT = FootprintModel_FootprintType_POINT;
  static const FootprintType CIRCULAR = FootprintModel_FootprintType_CIRCULAR;
  static const FootprintType TWOCIRCLES = FootprintModel_FootprintType_TWOCIRCLES;
  static const FootprintType LINE = FootprintModel_FootprintType_LINE;
  static const FootprintType POLYGON = FootprintModel_FootprintType_POLYGON;
  static inline bool FootprintType_IsValid(int value) {
    return FootprintModel_FootprintType_IsValid(value);
  }
  static const FootprintType FootprintType_MIN =
    FootprintModel_FootprintType_FootprintType_MIN;
  static const FootprintType FootprintType_MAX =
    FootprintModel_FootprintType_FootprintType_MAX;
  static const int FootprintType_ARRAYSIZE =
    FootprintModel_FootprintType_FootprintType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FootprintType_descriptor() {
    return FootprintModel_FootprintType_descriptor();
  }
  static inline const ::std::string& FootprintType_Name(FootprintType value) {
    return FootprintModel_FootprintType_Name(value);
  }
  static inline bool FootprintType_Parse(const ::std::string& name,
      FootprintType* value) {
    return FootprintModel_FootprintType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .rrts.planning.local_planner.FootprintModel.FootprintType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::rrts::planning::local_planner::FootprintModel_FootprintType type() const;
  inline void set_type(::rrts::planning::local_planner::FootprintModel_FootprintType value);

  // optional double radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline double radius() const;
  inline void set_radius(double value);

  // optional double front_offset = 3;
  inline bool has_front_offset() const;
  inline void clear_front_offset();
  static const int kFrontOffsetFieldNumber = 3;
  inline double front_offset() const;
  inline void set_front_offset(double value);

  // optional double front_radius = 4;
  inline bool has_front_radius() const;
  inline void clear_front_radius();
  static const int kFrontRadiusFieldNumber = 4;
  inline double front_radius() const;
  inline void set_front_radius(double value);

  // optional double rear_offset = 5;
  inline bool has_rear_offset() const;
  inline void clear_rear_offset();
  static const int kRearOffsetFieldNumber = 5;
  inline double rear_offset() const;
  inline void set_rear_offset(double value);

  // optional double rear_radius = 6;
  inline bool has_rear_radius() const;
  inline void clear_rear_radius();
  static const int kRearRadiusFieldNumber = 6;
  inline double rear_radius() const;
  inline void set_rear_radius(double value);

  // repeated .rrts.planning.local_planner.Point2D robot_vertices = 7;
  inline int robot_vertices_size() const;
  inline void clear_robot_vertices();
  static const int kRobotVerticesFieldNumber = 7;
  inline const ::rrts::planning::local_planner::Point2D& robot_vertices(int index) const;
  inline ::rrts::planning::local_planner::Point2D* mutable_robot_vertices(int index);
  inline ::rrts::planning::local_planner::Point2D* add_robot_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::Point2D >&
      robot_vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::Point2D >*
      mutable_robot_vertices();

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.FootprintModel)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_front_offset();
  inline void clear_has_front_offset();
  inline void set_has_front_radius();
  inline void clear_has_front_radius();
  inline void set_has_rear_offset();
  inline void clear_has_rear_offset();
  inline void set_has_rear_radius();
  inline void clear_has_rear_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double radius_;
  double front_offset_;
  double front_radius_;
  double rear_offset_;
  double rear_radius_;
  ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::Point2D > robot_vertices_;
  int type_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static FootprintModel* default_instance_;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  void Swap(Robot* other);

  // implements Message ----------------------------------------------

  Robot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_vel_x = 1;
  inline bool has_max_vel_x() const;
  inline void clear_max_vel_x();
  static const int kMaxVelXFieldNumber = 1;
  inline float max_vel_x() const;
  inline void set_max_vel_x(float value);

  // optional float max_vel_x_backwards = 2;
  inline bool has_max_vel_x_backwards() const;
  inline void clear_max_vel_x_backwards();
  static const int kMaxVelXBackwardsFieldNumber = 2;
  inline float max_vel_x_backwards() const;
  inline void set_max_vel_x_backwards(float value);

  // optional float max_vel_y = 3;
  inline bool has_max_vel_y() const;
  inline void clear_max_vel_y();
  static const int kMaxVelYFieldNumber = 3;
  inline float max_vel_y() const;
  inline void set_max_vel_y(float value);

  // optional float max_vel_theta = 4;
  inline bool has_max_vel_theta() const;
  inline void clear_max_vel_theta();
  static const int kMaxVelThetaFieldNumber = 4;
  inline float max_vel_theta() const;
  inline void set_max_vel_theta(float value);

  // optional float acc_lim_x = 5;
  inline bool has_acc_lim_x() const;
  inline void clear_acc_lim_x();
  static const int kAccLimXFieldNumber = 5;
  inline float acc_lim_x() const;
  inline void set_acc_lim_x(float value);

  // optional float acc_lim_y = 6;
  inline bool has_acc_lim_y() const;
  inline void clear_acc_lim_y();
  static const int kAccLimYFieldNumber = 6;
  inline float acc_lim_y() const;
  inline void set_acc_lim_y(float value);

  // optional float acc_lim_theta = 7;
  inline bool has_acc_lim_theta() const;
  inline void clear_acc_lim_theta();
  static const int kAccLimThetaFieldNumber = 7;
  inline float acc_lim_theta() const;
  inline void set_acc_lim_theta(float value);

  // optional float min_turning_radius = 8;
  inline bool has_min_turning_radius() const;
  inline void clear_min_turning_radius();
  static const int kMinTurningRadiusFieldNumber = 8;
  inline float min_turning_radius() const;
  inline void set_min_turning_radius(float value);

  // optional float wheelbase = 9;
  inline bool has_wheelbase() const;
  inline void clear_wheelbase();
  static const int kWheelbaseFieldNumber = 9;
  inline float wheelbase() const;
  inline void set_wheelbase(float value);

  // optional bool cmd_angle_instead_rotvel = 10;
  inline bool has_cmd_angle_instead_rotvel() const;
  inline void clear_cmd_angle_instead_rotvel();
  static const int kCmdAngleInsteadRotvelFieldNumber = 10;
  inline bool cmd_angle_instead_rotvel() const;
  inline void set_cmd_angle_instead_rotvel(bool value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Robot)
 private:
  inline void set_has_max_vel_x();
  inline void clear_has_max_vel_x();
  inline void set_has_max_vel_x_backwards();
  inline void clear_has_max_vel_x_backwards();
  inline void set_has_max_vel_y();
  inline void clear_has_max_vel_y();
  inline void set_has_max_vel_theta();
  inline void clear_has_max_vel_theta();
  inline void set_has_acc_lim_x();
  inline void clear_has_acc_lim_x();
  inline void set_has_acc_lim_y();
  inline void clear_has_acc_lim_y();
  inline void set_has_acc_lim_theta();
  inline void clear_has_acc_lim_theta();
  inline void set_has_min_turning_radius();
  inline void clear_has_min_turning_radius();
  inline void set_has_wheelbase();
  inline void clear_has_wheelbase();
  inline void set_has_cmd_angle_instead_rotvel();
  inline void clear_has_cmd_angle_instead_rotvel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float max_vel_x_;
  float max_vel_x_backwards_;
  float max_vel_y_;
  float max_vel_theta_;
  float acc_lim_x_;
  float acc_lim_y_;
  float acc_lim_theta_;
  float min_turning_radius_;
  float wheelbase_;
  bool cmd_angle_instead_rotvel_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Robot* default_instance_;
};
// -------------------------------------------------------------------

class GoalTolerance : public ::google::protobuf::Message {
 public:
  GoalTolerance();
  virtual ~GoalTolerance();

  GoalTolerance(const GoalTolerance& from);

  inline GoalTolerance& operator=(const GoalTolerance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalTolerance& default_instance();

  void Swap(GoalTolerance* other);

  // implements Message ----------------------------------------------

  GoalTolerance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoalTolerance& from);
  void MergeFrom(const GoalTolerance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float xy_goal_tolerance = 1;
  inline bool has_xy_goal_tolerance() const;
  inline void clear_xy_goal_tolerance();
  static const int kXyGoalToleranceFieldNumber = 1;
  inline float xy_goal_tolerance() const;
  inline void set_xy_goal_tolerance(float value);

  // optional float yaw_goal_tolerance = 2;
  inline bool has_yaw_goal_tolerance() const;
  inline void clear_yaw_goal_tolerance();
  static const int kYawGoalToleranceFieldNumber = 2;
  inline float yaw_goal_tolerance() const;
  inline void set_yaw_goal_tolerance(float value);

  // optional bool free_goal_vel = 3;
  inline bool has_free_goal_vel() const;
  inline void clear_free_goal_vel();
  static const int kFreeGoalVelFieldNumber = 3;
  inline bool free_goal_vel() const;
  inline void set_free_goal_vel(bool value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.GoalTolerance)
 private:
  inline void set_has_xy_goal_tolerance();
  inline void clear_has_xy_goal_tolerance();
  inline void set_has_yaw_goal_tolerance();
  inline void clear_has_yaw_goal_tolerance();
  inline void set_has_free_goal_vel();
  inline void clear_has_free_goal_vel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float xy_goal_tolerance_;
  float yaw_goal_tolerance_;
  bool free_goal_vel_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static GoalTolerance* default_instance_;
};
// -------------------------------------------------------------------

class Obstacles : public ::google::protobuf::Message {
 public:
  Obstacles();
  virtual ~Obstacles();

  Obstacles(const Obstacles& from);

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacles& default_instance();

  void Swap(Obstacles* other);

  // implements Message ----------------------------------------------

  Obstacles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Obstacles& from);
  void MergeFrom(const Obstacles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_obstacle_dist = 1;
  inline bool has_min_obstacle_dist() const;
  inline void clear_min_obstacle_dist();
  static const int kMinObstacleDistFieldNumber = 1;
  inline float min_obstacle_dist() const;
  inline void set_min_obstacle_dist(float value);

  // optional float inflation_dist = 2;
  inline bool has_inflation_dist() const;
  inline void clear_inflation_dist();
  static const int kInflationDistFieldNumber = 2;
  inline float inflation_dist() const;
  inline void set_inflation_dist(float value);

  // optional bool include_costmap_obstacles = 3;
  inline bool has_include_costmap_obstacles() const;
  inline void clear_include_costmap_obstacles();
  static const int kIncludeCostmapObstaclesFieldNumber = 3;
  inline bool include_costmap_obstacles() const;
  inline void set_include_costmap_obstacles(bool value);

  // optional float costmap_obstacles_behind_robot_dist = 4;
  inline bool has_costmap_obstacles_behind_robot_dist() const;
  inline void clear_costmap_obstacles_behind_robot_dist();
  static const int kCostmapObstaclesBehindRobotDistFieldNumber = 4;
  inline float costmap_obstacles_behind_robot_dist() const;
  inline void set_costmap_obstacles_behind_robot_dist(float value);

  // optional float obstacle_poses_affected = 5;
  inline bool has_obstacle_poses_affected() const;
  inline void clear_obstacle_poses_affected();
  static const int kObstaclePosesAffectedFieldNumber = 5;
  inline float obstacle_poses_affected() const;
  inline void set_obstacle_poses_affected(float value);

  // optional bool legacy_obstacle_association = 6;
  inline bool has_legacy_obstacle_association() const;
  inline void clear_legacy_obstacle_association();
  static const int kLegacyObstacleAssociationFieldNumber = 6;
  inline bool legacy_obstacle_association() const;
  inline void set_legacy_obstacle_association(bool value);

  // optional float obstacle_association_cutoff_factor = 7;
  inline bool has_obstacle_association_cutoff_factor() const;
  inline void clear_obstacle_association_cutoff_factor();
  static const int kObstacleAssociationCutoffFactorFieldNumber = 7;
  inline float obstacle_association_cutoff_factor() const;
  inline void set_obstacle_association_cutoff_factor(float value);

  // optional float obstacle_association_force_inclusion_factor = 8;
  inline bool has_obstacle_association_force_inclusion_factor() const;
  inline void clear_obstacle_association_force_inclusion_factor();
  static const int kObstacleAssociationForceInclusionFactorFieldNumber = 8;
  inline float obstacle_association_force_inclusion_factor() const;
  inline void set_obstacle_association_force_inclusion_factor(float value);

  // optional string costmap_converter_plugin = 9;
  inline bool has_costmap_converter_plugin() const;
  inline void clear_costmap_converter_plugin();
  static const int kCostmapConverterPluginFieldNumber = 9;
  inline const ::std::string& costmap_converter_plugin() const;
  inline void set_costmap_converter_plugin(const ::std::string& value);
  inline void set_costmap_converter_plugin(const char* value);
  inline void set_costmap_converter_plugin(const char* value, size_t size);
  inline ::std::string* mutable_costmap_converter_plugin();
  inline ::std::string* release_costmap_converter_plugin();
  inline void set_allocated_costmap_converter_plugin(::std::string* costmap_converter_plugin);

  // optional bool costmap_converter_spin_thread = 10;
  inline bool has_costmap_converter_spin_thread() const;
  inline void clear_costmap_converter_spin_thread();
  static const int kCostmapConverterSpinThreadFieldNumber = 10;
  inline bool costmap_converter_spin_thread() const;
  inline void set_costmap_converter_spin_thread(bool value);

  // optional float costmap_converter_rate = 11;
  inline bool has_costmap_converter_rate() const;
  inline void clear_costmap_converter_rate();
  static const int kCostmapConverterRateFieldNumber = 11;
  inline float costmap_converter_rate() const;
  inline void set_costmap_converter_rate(float value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Obstacles)
 private:
  inline void set_has_min_obstacle_dist();
  inline void clear_has_min_obstacle_dist();
  inline void set_has_inflation_dist();
  inline void clear_has_inflation_dist();
  inline void set_has_include_costmap_obstacles();
  inline void clear_has_include_costmap_obstacles();
  inline void set_has_costmap_obstacles_behind_robot_dist();
  inline void clear_has_costmap_obstacles_behind_robot_dist();
  inline void set_has_obstacle_poses_affected();
  inline void clear_has_obstacle_poses_affected();
  inline void set_has_legacy_obstacle_association();
  inline void clear_has_legacy_obstacle_association();
  inline void set_has_obstacle_association_cutoff_factor();
  inline void clear_has_obstacle_association_cutoff_factor();
  inline void set_has_obstacle_association_force_inclusion_factor();
  inline void clear_has_obstacle_association_force_inclusion_factor();
  inline void set_has_costmap_converter_plugin();
  inline void clear_has_costmap_converter_plugin();
  inline void set_has_costmap_converter_spin_thread();
  inline void clear_has_costmap_converter_spin_thread();
  inline void set_has_costmap_converter_rate();
  inline void clear_has_costmap_converter_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float min_obstacle_dist_;
  float inflation_dist_;
  float costmap_obstacles_behind_robot_dist_;
  float obstacle_poses_affected_;
  bool include_costmap_obstacles_;
  bool legacy_obstacle_association_;
  bool costmap_converter_spin_thread_;
  float obstacle_association_cutoff_factor_;
  ::std::string* costmap_converter_plugin_;
  float obstacle_association_force_inclusion_factor_;
  float costmap_converter_rate_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Obstacles* default_instance_;
};
// -------------------------------------------------------------------

class Optimization : public ::google::protobuf::Message {
 public:
  Optimization();
  virtual ~Optimization();

  Optimization(const Optimization& from);

  inline Optimization& operator=(const Optimization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Optimization& default_instance();

  void Swap(Optimization* other);

  // implements Message ----------------------------------------------

  Optimization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Optimization& from);
  void MergeFrom(const Optimization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 no_inner_iterations = 1;
  inline bool has_no_inner_iterations() const;
  inline void clear_no_inner_iterations();
  static const int kNoInnerIterationsFieldNumber = 1;
  inline ::google::protobuf::int32 no_inner_iterations() const;
  inline void set_no_inner_iterations(::google::protobuf::int32 value);

  // optional int32 no_outer_iterations = 2;
  inline bool has_no_outer_iterations() const;
  inline void clear_no_outer_iterations();
  static const int kNoOuterIterationsFieldNumber = 2;
  inline ::google::protobuf::int32 no_outer_iterations() const;
  inline void set_no_outer_iterations(::google::protobuf::int32 value);

  // optional bool optimization_activate = 3;
  inline bool has_optimization_activate() const;
  inline void clear_optimization_activate();
  static const int kOptimizationActivateFieldNumber = 3;
  inline bool optimization_activate() const;
  inline void set_optimization_activate(bool value);

  // optional bool optimization_verbose = 4;
  inline bool has_optimization_verbose() const;
  inline void clear_optimization_verbose();
  static const int kOptimizationVerboseFieldNumber = 4;
  inline bool optimization_verbose() const;
  inline void set_optimization_verbose(bool value);

  // optional float penalty_epsilon = 5;
  inline bool has_penalty_epsilon() const;
  inline void clear_penalty_epsilon();
  static const int kPenaltyEpsilonFieldNumber = 5;
  inline float penalty_epsilon() const;
  inline void set_penalty_epsilon(float value);

  // optional float weight_max_vel_x = 6;
  inline bool has_weight_max_vel_x() const;
  inline void clear_weight_max_vel_x();
  static const int kWeightMaxVelXFieldNumber = 6;
  inline float weight_max_vel_x() const;
  inline void set_weight_max_vel_x(float value);

  // optional float weight_max_vel_y = 7;
  inline bool has_weight_max_vel_y() const;
  inline void clear_weight_max_vel_y();
  static const int kWeightMaxVelYFieldNumber = 7;
  inline float weight_max_vel_y() const;
  inline void set_weight_max_vel_y(float value);

  // optional float weight_max_vel_theta = 8;
  inline bool has_weight_max_vel_theta() const;
  inline void clear_weight_max_vel_theta();
  static const int kWeightMaxVelThetaFieldNumber = 8;
  inline float weight_max_vel_theta() const;
  inline void set_weight_max_vel_theta(float value);

  // optional float weight_acc_lim_x = 9;
  inline bool has_weight_acc_lim_x() const;
  inline void clear_weight_acc_lim_x();
  static const int kWeightAccLimXFieldNumber = 9;
  inline float weight_acc_lim_x() const;
  inline void set_weight_acc_lim_x(float value);

  // optional float weight_acc_lim_y = 10;
  inline bool has_weight_acc_lim_y() const;
  inline void clear_weight_acc_lim_y();
  static const int kWeightAccLimYFieldNumber = 10;
  inline float weight_acc_lim_y() const;
  inline void set_weight_acc_lim_y(float value);

  // optional float weight_acc_lim_thet = 11;
  inline bool has_weight_acc_lim_thet() const;
  inline void clear_weight_acc_lim_thet();
  static const int kWeightAccLimThetFieldNumber = 11;
  inline float weight_acc_lim_thet() const;
  inline void set_weight_acc_lim_thet(float value);

  // optional float weight_kinematics_nh = 12;
  inline bool has_weight_kinematics_nh() const;
  inline void clear_weight_kinematics_nh();
  static const int kWeightKinematicsNhFieldNumber = 12;
  inline float weight_kinematics_nh() const;
  inline void set_weight_kinematics_nh(float value);

  // optional float weight_kinematics_forward_drive = 13;
  inline bool has_weight_kinematics_forward_drive() const;
  inline void clear_weight_kinematics_forward_drive();
  static const int kWeightKinematicsForwardDriveFieldNumber = 13;
  inline float weight_kinematics_forward_drive() const;
  inline void set_weight_kinematics_forward_drive(float value);

  // optional float weight_kinematics_turning_radius = 14;
  inline bool has_weight_kinematics_turning_radius() const;
  inline void clear_weight_kinematics_turning_radius();
  static const int kWeightKinematicsTurningRadiusFieldNumber = 14;
  inline float weight_kinematics_turning_radius() const;
  inline void set_weight_kinematics_turning_radius(float value);

  // optional float weight_optimaltime = 15;
  inline bool has_weight_optimaltime() const;
  inline void clear_weight_optimaltime();
  static const int kWeightOptimaltimeFieldNumber = 15;
  inline float weight_optimaltime() const;
  inline void set_weight_optimaltime(float value);

  // optional float weight_obstacle = 16;
  inline bool has_weight_obstacle() const;
  inline void clear_weight_obstacle();
  static const int kWeightObstacleFieldNumber = 16;
  inline float weight_obstacle() const;
  inline void set_weight_obstacle(float value);

  // optional float weight_inflation = 17;
  inline bool has_weight_inflation() const;
  inline void clear_weight_inflation();
  static const int kWeightInflationFieldNumber = 17;
  inline float weight_inflation() const;
  inline void set_weight_inflation(float value);

  // optional float weight_dynamic_obstacle = 18;
  inline bool has_weight_dynamic_obstacle() const;
  inline void clear_weight_dynamic_obstacle();
  static const int kWeightDynamicObstacleFieldNumber = 18;
  inline float weight_dynamic_obstacle() const;
  inline void set_weight_dynamic_obstacle(float value);

  // optional float weight_viapoint = 19;
  inline bool has_weight_viapoint() const;
  inline void clear_weight_viapoint();
  static const int kWeightViapointFieldNumber = 19;
  inline float weight_viapoint() const;
  inline void set_weight_viapoint(float value);

  // optional float weight_adapt_factor = 20;
  inline bool has_weight_adapt_factor() const;
  inline void clear_weight_adapt_factor();
  static const int kWeightAdaptFactorFieldNumber = 20;
  inline float weight_adapt_factor() const;
  inline void set_weight_adapt_factor(float value);

  // optional float weight_prefer_rotdir = 21;
  inline bool has_weight_prefer_rotdir() const;
  inline void clear_weight_prefer_rotdir();
  static const int kWeightPreferRotdirFieldNumber = 21;
  inline float weight_prefer_rotdir() const;
  inline void set_weight_prefer_rotdir(float value);

  // optional float weight_acc_lim_theta = 22;
  inline bool has_weight_acc_lim_theta() const;
  inline void clear_weight_acc_lim_theta();
  static const int kWeightAccLimThetaFieldNumber = 22;
  inline float weight_acc_lim_theta() const;
  inline void set_weight_acc_lim_theta(float value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Optimization)
 private:
  inline void set_has_no_inner_iterations();
  inline void clear_has_no_inner_iterations();
  inline void set_has_no_outer_iterations();
  inline void clear_has_no_outer_iterations();
  inline void set_has_optimization_activate();
  inline void clear_has_optimization_activate();
  inline void set_has_optimization_verbose();
  inline void clear_has_optimization_verbose();
  inline void set_has_penalty_epsilon();
  inline void clear_has_penalty_epsilon();
  inline void set_has_weight_max_vel_x();
  inline void clear_has_weight_max_vel_x();
  inline void set_has_weight_max_vel_y();
  inline void clear_has_weight_max_vel_y();
  inline void set_has_weight_max_vel_theta();
  inline void clear_has_weight_max_vel_theta();
  inline void set_has_weight_acc_lim_x();
  inline void clear_has_weight_acc_lim_x();
  inline void set_has_weight_acc_lim_y();
  inline void clear_has_weight_acc_lim_y();
  inline void set_has_weight_acc_lim_thet();
  inline void clear_has_weight_acc_lim_thet();
  inline void set_has_weight_kinematics_nh();
  inline void clear_has_weight_kinematics_nh();
  inline void set_has_weight_kinematics_forward_drive();
  inline void clear_has_weight_kinematics_forward_drive();
  inline void set_has_weight_kinematics_turning_radius();
  inline void clear_has_weight_kinematics_turning_radius();
  inline void set_has_weight_optimaltime();
  inline void clear_has_weight_optimaltime();
  inline void set_has_weight_obstacle();
  inline void clear_has_weight_obstacle();
  inline void set_has_weight_inflation();
  inline void clear_has_weight_inflation();
  inline void set_has_weight_dynamic_obstacle();
  inline void clear_has_weight_dynamic_obstacle();
  inline void set_has_weight_viapoint();
  inline void clear_has_weight_viapoint();
  inline void set_has_weight_adapt_factor();
  inline void clear_has_weight_adapt_factor();
  inline void set_has_weight_prefer_rotdir();
  inline void clear_has_weight_prefer_rotdir();
  inline void set_has_weight_acc_lim_theta();
  inline void clear_has_weight_acc_lim_theta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 no_inner_iterations_;
  ::google::protobuf::int32 no_outer_iterations_;
  bool optimization_activate_;
  bool optimization_verbose_;
  float penalty_epsilon_;
  float weight_max_vel_x_;
  float weight_max_vel_y_;
  float weight_max_vel_theta_;
  float weight_acc_lim_x_;
  float weight_acc_lim_y_;
  float weight_acc_lim_thet_;
  float weight_kinematics_nh_;
  float weight_kinematics_forward_drive_;
  float weight_kinematics_turning_radius_;
  float weight_optimaltime_;
  float weight_obstacle_;
  float weight_inflation_;
  float weight_dynamic_obstacle_;
  float weight_viapoint_;
  float weight_adapt_factor_;
  float weight_prefer_rotdir_;
  float weight_acc_lim_theta_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Optimization* default_instance_;
};
// -------------------------------------------------------------------

class HomotopyClassPlanner : public ::google::protobuf::Message {
 public:
  HomotopyClassPlanner();
  virtual ~HomotopyClassPlanner();

  HomotopyClassPlanner(const HomotopyClassPlanner& from);

  inline HomotopyClassPlanner& operator=(const HomotopyClassPlanner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HomotopyClassPlanner& default_instance();

  void Swap(HomotopyClassPlanner* other);

  // implements Message ----------------------------------------------

  HomotopyClassPlanner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HomotopyClassPlanner& from);
  void MergeFrom(const HomotopyClassPlanner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_homotopy_class_planning = 1;
  inline bool has_enable_homotopy_class_planning() const;
  inline void clear_enable_homotopy_class_planning();
  static const int kEnableHomotopyClassPlanningFieldNumber = 1;
  inline bool enable_homotopy_class_planning() const;
  inline void set_enable_homotopy_class_planning(bool value);

  // optional bool enable_multithreading = 2;
  inline bool has_enable_multithreading() const;
  inline void clear_enable_multithreading();
  static const int kEnableMultithreadingFieldNumber = 2;
  inline bool enable_multithreading() const;
  inline void set_enable_multithreading(bool value);

  // optional bool simple_exploration = 3;
  inline bool has_simple_exploration() const;
  inline void clear_simple_exploration();
  static const int kSimpleExplorationFieldNumber = 3;
  inline bool simple_exploration() const;
  inline void set_simple_exploration(bool value);

  // optional int32 max_number_classes = 4;
  inline bool has_max_number_classes() const;
  inline void clear_max_number_classes();
  static const int kMaxNumberClassesFieldNumber = 4;
  inline ::google::protobuf::int32 max_number_classes() const;
  inline void set_max_number_classes(::google::protobuf::int32 value);

  // optional float selection_obst_cost_scale = 5;
  inline bool has_selection_obst_cost_scale() const;
  inline void clear_selection_obst_cost_scale();
  static const int kSelectionObstCostScaleFieldNumber = 5;
  inline float selection_obst_cost_scale() const;
  inline void set_selection_obst_cost_scale(float value);

  // optional float selection_prefer_initial_plan = 6;
  inline bool has_selection_prefer_initial_plan() const;
  inline void clear_selection_prefer_initial_plan();
  static const int kSelectionPreferInitialPlanFieldNumber = 6;
  inline float selection_prefer_initial_plan() const;
  inline void set_selection_prefer_initial_plan(float value);

  // optional float selection_viapoint_cost_scale = 7;
  inline bool has_selection_viapoint_cost_scale() const;
  inline void clear_selection_viapoint_cost_scale();
  static const int kSelectionViapointCostScaleFieldNumber = 7;
  inline float selection_viapoint_cost_scale() const;
  inline void set_selection_viapoint_cost_scale(float value);

  // optional float selection_cost_hysteresis = 8;
  inline bool has_selection_cost_hysteresis() const;
  inline void clear_selection_cost_hysteresis();
  static const int kSelectionCostHysteresisFieldNumber = 8;
  inline float selection_cost_hysteresis() const;
  inline void set_selection_cost_hysteresis(float value);

  // optional bool selection_alternative_time_cost = 9;
  inline bool has_selection_alternative_time_cost() const;
  inline void clear_selection_alternative_time_cost();
  static const int kSelectionAlternativeTimeCostFieldNumber = 9;
  inline bool selection_alternative_time_cost() const;
  inline void set_selection_alternative_time_cost(bool value);

  // optional int32 roadmap_graph_no_samples = 10;
  inline bool has_roadmap_graph_no_samples() const;
  inline void clear_roadmap_graph_no_samples();
  static const int kRoadmapGraphNoSamplesFieldNumber = 10;
  inline ::google::protobuf::int32 roadmap_graph_no_samples() const;
  inline void set_roadmap_graph_no_samples(::google::protobuf::int32 value);

  // optional int32 roadmap_graph_area_width = 11;
  inline bool has_roadmap_graph_area_width() const;
  inline void clear_roadmap_graph_area_width();
  static const int kRoadmapGraphAreaWidthFieldNumber = 11;
  inline ::google::protobuf::int32 roadmap_graph_area_width() const;
  inline void set_roadmap_graph_area_width(::google::protobuf::int32 value);

  // optional float roadmap_graph_area_length_scale = 12;
  inline bool has_roadmap_graph_area_length_scale() const;
  inline void clear_roadmap_graph_area_length_scale();
  static const int kRoadmapGraphAreaLengthScaleFieldNumber = 12;
  inline float roadmap_graph_area_length_scale() const;
  inline void set_roadmap_graph_area_length_scale(float value);

  // optional float h_signature_prescaler = 13;
  inline bool has_h_signature_prescaler() const;
  inline void clear_h_signature_prescaler();
  static const int kHSignaturePrescalerFieldNumber = 13;
  inline float h_signature_prescaler() const;
  inline void set_h_signature_prescaler(float value);

  // optional float h_signature_threshold = 14;
  inline bool has_h_signature_threshold() const;
  inline void clear_h_signature_threshold();
  static const int kHSignatureThresholdFieldNumber = 14;
  inline float h_signature_threshold() const;
  inline void set_h_signature_threshold(float value);

  // optional float obstacle_keypoint_offset = 15;
  inline bool has_obstacle_keypoint_offset() const;
  inline void clear_obstacle_keypoint_offset();
  static const int kObstacleKeypointOffsetFieldNumber = 15;
  inline float obstacle_keypoint_offset() const;
  inline void set_obstacle_keypoint_offset(float value);

  // optional float obstacle_heading_threshold = 16;
  inline bool has_obstacle_heading_threshold() const;
  inline void clear_obstacle_heading_threshold();
  static const int kObstacleHeadingThresholdFieldNumber = 16;
  inline float obstacle_heading_threshold() const;
  inline void set_obstacle_heading_threshold(float value);

  // optional bool viapoints_all_candidates = 17;
  inline bool has_viapoints_all_candidates() const;
  inline void clear_viapoints_all_candidates();
  static const int kViapointsAllCandidatesFieldNumber = 17;
  inline bool viapoints_all_candidates() const;
  inline void set_viapoints_all_candidates(bool value);

  // optional bool visualize_hc_graph = 18;
  inline bool has_visualize_hc_graph() const;
  inline void clear_visualize_hc_graph();
  static const int kVisualizeHcGraphFieldNumber = 18;
  inline bool visualize_hc_graph() const;
  inline void set_visualize_hc_graph(bool value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.HomotopyClassPlanner)
 private:
  inline void set_has_enable_homotopy_class_planning();
  inline void clear_has_enable_homotopy_class_planning();
  inline void set_has_enable_multithreading();
  inline void clear_has_enable_multithreading();
  inline void set_has_simple_exploration();
  inline void clear_has_simple_exploration();
  inline void set_has_max_number_classes();
  inline void clear_has_max_number_classes();
  inline void set_has_selection_obst_cost_scale();
  inline void clear_has_selection_obst_cost_scale();
  inline void set_has_selection_prefer_initial_plan();
  inline void clear_has_selection_prefer_initial_plan();
  inline void set_has_selection_viapoint_cost_scale();
  inline void clear_has_selection_viapoint_cost_scale();
  inline void set_has_selection_cost_hysteresis();
  inline void clear_has_selection_cost_hysteresis();
  inline void set_has_selection_alternative_time_cost();
  inline void clear_has_selection_alternative_time_cost();
  inline void set_has_roadmap_graph_no_samples();
  inline void clear_has_roadmap_graph_no_samples();
  inline void set_has_roadmap_graph_area_width();
  inline void clear_has_roadmap_graph_area_width();
  inline void set_has_roadmap_graph_area_length_scale();
  inline void clear_has_roadmap_graph_area_length_scale();
  inline void set_has_h_signature_prescaler();
  inline void clear_has_h_signature_prescaler();
  inline void set_has_h_signature_threshold();
  inline void clear_has_h_signature_threshold();
  inline void set_has_obstacle_keypoint_offset();
  inline void clear_has_obstacle_keypoint_offset();
  inline void set_has_obstacle_heading_threshold();
  inline void clear_has_obstacle_heading_threshold();
  inline void set_has_viapoints_all_candidates();
  inline void clear_has_viapoints_all_candidates();
  inline void set_has_visualize_hc_graph();
  inline void clear_has_visualize_hc_graph();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool enable_homotopy_class_planning_;
  bool enable_multithreading_;
  bool simple_exploration_;
  bool selection_alternative_time_cost_;
  ::google::protobuf::int32 max_number_classes_;
  float selection_obst_cost_scale_;
  float selection_prefer_initial_plan_;
  float selection_viapoint_cost_scale_;
  float selection_cost_hysteresis_;
  ::google::protobuf::int32 roadmap_graph_no_samples_;
  ::google::protobuf::int32 roadmap_graph_area_width_;
  float roadmap_graph_area_length_scale_;
  float h_signature_prescaler_;
  float h_signature_threshold_;
  float obstacle_keypoint_offset_;
  float obstacle_heading_threshold_;
  bool viapoints_all_candidates_;
  bool visualize_hc_graph_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static HomotopyClassPlanner* default_instance_;
};
// -------------------------------------------------------------------

class Recovery : public ::google::protobuf::Message {
 public:
  Recovery();
  virtual ~Recovery();

  Recovery(const Recovery& from);

  inline Recovery& operator=(const Recovery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Recovery& default_instance();

  void Swap(Recovery* other);

  // implements Message ----------------------------------------------

  Recovery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Recovery& from);
  void MergeFrom(const Recovery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool shrink_horizon_min_duration = 1;
  inline bool has_shrink_horizon_min_duration() const;
  inline void clear_shrink_horizon_min_duration();
  static const int kShrinkHorizonMinDurationFieldNumber = 1;
  inline bool shrink_horizon_min_duration() const;
  inline void set_shrink_horizon_min_duration(bool value);

  // optional bool oscillation_recovery = 2;
  inline bool has_oscillation_recovery() const;
  inline void clear_oscillation_recovery();
  static const int kOscillationRecoveryFieldNumber = 2;
  inline bool oscillation_recovery() const;
  inline void set_oscillation_recovery(bool value);

  // optional bool shrink_horizon_backup = 3;
  inline bool has_shrink_horizon_backup() const;
  inline void clear_shrink_horizon_backup();
  static const int kShrinkHorizonBackupFieldNumber = 3;
  inline bool shrink_horizon_backup() const;
  inline void set_shrink_horizon_backup(bool value);

  // optional double oscillation_v_eps = 4;
  inline bool has_oscillation_v_eps() const;
  inline void clear_oscillation_v_eps();
  static const int kOscillationVEpsFieldNumber = 4;
  inline double oscillation_v_eps() const;
  inline void set_oscillation_v_eps(double value);

  // optional double oscillation_omega_eps = 5;
  inline bool has_oscillation_omega_eps() const;
  inline void clear_oscillation_omega_eps();
  static const int kOscillationOmegaEpsFieldNumber = 5;
  inline double oscillation_omega_eps() const;
  inline void set_oscillation_omega_eps(double value);

  // optional double oscillation_recovery_min_duration = 6;
  inline bool has_oscillation_recovery_min_duration() const;
  inline void clear_oscillation_recovery_min_duration();
  static const int kOscillationRecoveryMinDurationFieldNumber = 6;
  inline double oscillation_recovery_min_duration() const;
  inline void set_oscillation_recovery_min_duration(double value);

  // optional double oscillation_filter_duration = 7;
  inline bool has_oscillation_filter_duration() const;
  inline void clear_oscillation_filter_duration();
  static const int kOscillationFilterDurationFieldNumber = 7;
  inline double oscillation_filter_duration() const;
  inline void set_oscillation_filter_duration(double value);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Recovery)
 private:
  inline void set_has_shrink_horizon_min_duration();
  inline void clear_has_shrink_horizon_min_duration();
  inline void set_has_oscillation_recovery();
  inline void clear_has_oscillation_recovery();
  inline void set_has_shrink_horizon_backup();
  inline void clear_has_shrink_horizon_backup();
  inline void set_has_oscillation_v_eps();
  inline void clear_has_oscillation_v_eps();
  inline void set_has_oscillation_omega_eps();
  inline void clear_has_oscillation_omega_eps();
  inline void set_has_oscillation_recovery_min_duration();
  inline void clear_has_oscillation_recovery_min_duration();
  inline void set_has_oscillation_filter_duration();
  inline void clear_has_oscillation_filter_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double oscillation_v_eps_;
  double oscillation_omega_eps_;
  double oscillation_recovery_min_duration_;
  double oscillation_filter_duration_;
  bool shrink_horizon_min_duration_;
  bool oscillation_recovery_;
  bool shrink_horizon_backup_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Recovery* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rrts.planning.local_planner.FrameID opt_frame = 1;
  inline bool has_opt_frame() const;
  inline void clear_opt_frame();
  static const int kOptFrameFieldNumber = 1;
  inline const ::rrts::planning::local_planner::FrameID& opt_frame() const;
  inline ::rrts::planning::local_planner::FrameID* mutable_opt_frame();
  inline ::rrts::planning::local_planner::FrameID* release_opt_frame();
  inline void set_allocated_opt_frame(::rrts::planning::local_planner::FrameID* opt_frame);

  // optional .rrts.planning.local_planner.Trajectory trajectory_opt = 2;
  inline bool has_trajectory_opt() const;
  inline void clear_trajectory_opt();
  static const int kTrajectoryOptFieldNumber = 2;
  inline const ::rrts::planning::local_planner::Trajectory& trajectory_opt() const;
  inline ::rrts::planning::local_planner::Trajectory* mutable_trajectory_opt();
  inline ::rrts::planning::local_planner::Trajectory* release_trajectory_opt();
  inline void set_allocated_trajectory_opt(::rrts::planning::local_planner::Trajectory* trajectory_opt);

  // optional .rrts.planning.local_planner.Robot kinematics_opt = 3;
  inline bool has_kinematics_opt() const;
  inline void clear_kinematics_opt();
  static const int kKinematicsOptFieldNumber = 3;
  inline const ::rrts::planning::local_planner::Robot& kinematics_opt() const;
  inline ::rrts::planning::local_planner::Robot* mutable_kinematics_opt();
  inline ::rrts::planning::local_planner::Robot* release_kinematics_opt();
  inline void set_allocated_kinematics_opt(::rrts::planning::local_planner::Robot* kinematics_opt);

  // optional .rrts.planning.local_planner.GoalTolerance tolerance_opt = 4;
  inline bool has_tolerance_opt() const;
  inline void clear_tolerance_opt();
  static const int kToleranceOptFieldNumber = 4;
  inline const ::rrts::planning::local_planner::GoalTolerance& tolerance_opt() const;
  inline ::rrts::planning::local_planner::GoalTolerance* mutable_tolerance_opt();
  inline ::rrts::planning::local_planner::GoalTolerance* release_tolerance_opt();
  inline void set_allocated_tolerance_opt(::rrts::planning::local_planner::GoalTolerance* tolerance_opt);

  // optional .rrts.planning.local_planner.Obstacles obstacles_opt = 5;
  inline bool has_obstacles_opt() const;
  inline void clear_obstacles_opt();
  static const int kObstaclesOptFieldNumber = 5;
  inline const ::rrts::planning::local_planner::Obstacles& obstacles_opt() const;
  inline ::rrts::planning::local_planner::Obstacles* mutable_obstacles_opt();
  inline ::rrts::planning::local_planner::Obstacles* release_obstacles_opt();
  inline void set_allocated_obstacles_opt(::rrts::planning::local_planner::Obstacles* obstacles_opt);

  // optional .rrts.planning.local_planner.Optimization optimize_info = 6;
  inline bool has_optimize_info() const;
  inline void clear_optimize_info();
  static const int kOptimizeInfoFieldNumber = 6;
  inline const ::rrts::planning::local_planner::Optimization& optimize_info() const;
  inline ::rrts::planning::local_planner::Optimization* mutable_optimize_info();
  inline ::rrts::planning::local_planner::Optimization* release_optimize_info();
  inline void set_allocated_optimize_info(::rrts::planning::local_planner::Optimization* optimize_info);

  // optional .rrts.planning.local_planner.HomotopyClassPlanner hcp_opt = 7;
  inline bool has_hcp_opt() const;
  inline void clear_hcp_opt();
  static const int kHcpOptFieldNumber = 7;
  inline const ::rrts::planning::local_planner::HomotopyClassPlanner& hcp_opt() const;
  inline ::rrts::planning::local_planner::HomotopyClassPlanner* mutable_hcp_opt();
  inline ::rrts::planning::local_planner::HomotopyClassPlanner* release_hcp_opt();
  inline void set_allocated_hcp_opt(::rrts::planning::local_planner::HomotopyClassPlanner* hcp_opt);

  // repeated .rrts.planning.local_planner.FootprintModel robot_type = 8;
  inline int robot_type_size() const;
  inline void clear_robot_type();
  static const int kRobotTypeFieldNumber = 8;
  inline const ::rrts::planning::local_planner::FootprintModel& robot_type(int index) const;
  inline ::rrts::planning::local_planner::FootprintModel* mutable_robot_type(int index);
  inline ::rrts::planning::local_planner::FootprintModel* add_robot_type();
  inline const ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::FootprintModel >&
      robot_type() const;
  inline ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::FootprintModel >*
      mutable_robot_type();

  // optional .rrts.planning.local_planner.Recovery recovery_info = 9;
  inline bool has_recovery_info() const;
  inline void clear_recovery_info();
  static const int kRecoveryInfoFieldNumber = 9;
  inline const ::rrts::planning::local_planner::Recovery& recovery_info() const;
  inline ::rrts::planning::local_planner::Recovery* mutable_recovery_info();
  inline ::rrts::planning::local_planner::Recovery* release_recovery_info();
  inline void set_allocated_recovery_info(::rrts::planning::local_planner::Recovery* recovery_info);

  // @@protoc_insertion_point(class_scope:rrts.planning.local_planner.Config)
 private:
  inline void set_has_opt_frame();
  inline void clear_has_opt_frame();
  inline void set_has_trajectory_opt();
  inline void clear_has_trajectory_opt();
  inline void set_has_kinematics_opt();
  inline void clear_has_kinematics_opt();
  inline void set_has_tolerance_opt();
  inline void clear_has_tolerance_opt();
  inline void set_has_obstacles_opt();
  inline void clear_has_obstacles_opt();
  inline void set_has_optimize_info();
  inline void clear_has_optimize_info();
  inline void set_has_hcp_opt();
  inline void clear_has_hcp_opt();
  inline void set_has_recovery_info();
  inline void clear_has_recovery_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rrts::planning::local_planner::FrameID* opt_frame_;
  ::rrts::planning::local_planner::Trajectory* trajectory_opt_;
  ::rrts::planning::local_planner::Robot* kinematics_opt_;
  ::rrts::planning::local_planner::GoalTolerance* tolerance_opt_;
  ::rrts::planning::local_planner::Obstacles* obstacles_opt_;
  ::rrts::planning::local_planner::Optimization* optimize_info_;
  ::rrts::planning::local_planner::HomotopyClassPlanner* hcp_opt_;
  ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::FootprintModel > robot_type_;
  ::rrts::planning::local_planner::Recovery* recovery_info_;
  friend void  protobuf_AddDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_AssignDesc_timed_5felastic_5fband_2eproto();
  friend void protobuf_ShutdownFile_timed_5felastic_5fband_2eproto();

  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// ===================================================================


// ===================================================================

// FrameID

// optional string odom_frame = 1;
inline bool FrameID::has_odom_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameID::set_has_odom_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameID::clear_has_odom_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameID::clear_odom_frame() {
  if (odom_frame_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    odom_frame_->clear();
  }
  clear_has_odom_frame();
}
inline const ::std::string& FrameID::odom_frame() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FrameID.odom_frame)
  return *odom_frame_;
}
inline void FrameID::set_odom_frame(const ::std::string& value) {
  set_has_odom_frame();
  if (odom_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    odom_frame_ = new ::std::string;
  }
  odom_frame_->assign(value);
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FrameID.odom_frame)
}
inline void FrameID::set_odom_frame(const char* value) {
  set_has_odom_frame();
  if (odom_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    odom_frame_ = new ::std::string;
  }
  odom_frame_->assign(value);
  // @@protoc_insertion_point(field_set_char:rrts.planning.local_planner.FrameID.odom_frame)
}
inline void FrameID::set_odom_frame(const char* value, size_t size) {
  set_has_odom_frame();
  if (odom_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    odom_frame_ = new ::std::string;
  }
  odom_frame_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rrts.planning.local_planner.FrameID.odom_frame)
}
inline ::std::string* FrameID::mutable_odom_frame() {
  set_has_odom_frame();
  if (odom_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    odom_frame_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.FrameID.odom_frame)
  return odom_frame_;
}
inline ::std::string* FrameID::release_odom_frame() {
  clear_has_odom_frame();
  if (odom_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = odom_frame_;
    odom_frame_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameID::set_allocated_odom_frame(::std::string* odom_frame) {
  if (odom_frame_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete odom_frame_;
  }
  if (odom_frame) {
    set_has_odom_frame();
    odom_frame_ = odom_frame;
  } else {
    clear_has_odom_frame();
    odom_frame_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.FrameID.odom_frame)
}

// optional string map_frame = 2;
inline bool FrameID::has_map_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameID::set_has_map_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameID::clear_has_map_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameID::clear_map_frame() {
  if (map_frame_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    map_frame_->clear();
  }
  clear_has_map_frame();
}
inline const ::std::string& FrameID::map_frame() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FrameID.map_frame)
  return *map_frame_;
}
inline void FrameID::set_map_frame(const ::std::string& value) {
  set_has_map_frame();
  if (map_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    map_frame_ = new ::std::string;
  }
  map_frame_->assign(value);
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FrameID.map_frame)
}
inline void FrameID::set_map_frame(const char* value) {
  set_has_map_frame();
  if (map_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    map_frame_ = new ::std::string;
  }
  map_frame_->assign(value);
  // @@protoc_insertion_point(field_set_char:rrts.planning.local_planner.FrameID.map_frame)
}
inline void FrameID::set_map_frame(const char* value, size_t size) {
  set_has_map_frame();
  if (map_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    map_frame_ = new ::std::string;
  }
  map_frame_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rrts.planning.local_planner.FrameID.map_frame)
}
inline ::std::string* FrameID::mutable_map_frame() {
  set_has_map_frame();
  if (map_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    map_frame_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.FrameID.map_frame)
  return map_frame_;
}
inline ::std::string* FrameID::release_map_frame() {
  clear_has_map_frame();
  if (map_frame_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = map_frame_;
    map_frame_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrameID::set_allocated_map_frame(::std::string* map_frame) {
  if (map_frame_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete map_frame_;
  }
  if (map_frame) {
    set_has_map_frame();
    map_frame_ = map_frame;
  } else {
    clear_has_map_frame();
    map_frame_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.FrameID.map_frame)
}

// -------------------------------------------------------------------

// Point2D

// optional float x = 1;
inline bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Point2D.x)
  return x_;
}
inline void Point2D::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Point2D.x)
}

// optional float y = 2;
inline bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Point2D.y)
  return y_;
}
inline void Point2D::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Point2D.y)
}

// -------------------------------------------------------------------

// Trajectory

// optional bool teb_autosize = 1;
inline bool Trajectory::has_teb_autosize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trajectory::set_has_teb_autosize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trajectory::clear_has_teb_autosize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trajectory::clear_teb_autosize() {
  teb_autosize_ = false;
  clear_has_teb_autosize();
}
inline bool Trajectory::teb_autosize() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.teb_autosize)
  return teb_autosize_;
}
inline void Trajectory::set_teb_autosize(bool value) {
  set_has_teb_autosize();
  teb_autosize_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.teb_autosize)
}

// optional float dt_ref = 2;
inline bool Trajectory::has_dt_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trajectory::set_has_dt_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trajectory::clear_has_dt_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trajectory::clear_dt_ref() {
  dt_ref_ = 0;
  clear_has_dt_ref();
}
inline float Trajectory::dt_ref() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.dt_ref)
  return dt_ref_;
}
inline void Trajectory::set_dt_ref(float value) {
  set_has_dt_ref();
  dt_ref_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.dt_ref)
}

// optional float dt_hysteresis = 3;
inline bool Trajectory::has_dt_hysteresis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trajectory::set_has_dt_hysteresis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trajectory::clear_has_dt_hysteresis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trajectory::clear_dt_hysteresis() {
  dt_hysteresis_ = 0;
  clear_has_dt_hysteresis();
}
inline float Trajectory::dt_hysteresis() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.dt_hysteresis)
  return dt_hysteresis_;
}
inline void Trajectory::set_dt_hysteresis(float value) {
  set_has_dt_hysteresis();
  dt_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.dt_hysteresis)
}

// optional bool global_plan_overwrite_orientation = 4;
inline bool Trajectory::has_global_plan_overwrite_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trajectory::set_has_global_plan_overwrite_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trajectory::clear_has_global_plan_overwrite_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trajectory::clear_global_plan_overwrite_orientation() {
  global_plan_overwrite_orientation_ = false;
  clear_has_global_plan_overwrite_orientation();
}
inline bool Trajectory::global_plan_overwrite_orientation() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.global_plan_overwrite_orientation)
  return global_plan_overwrite_orientation_;
}
inline void Trajectory::set_global_plan_overwrite_orientation(bool value) {
  set_has_global_plan_overwrite_orientation();
  global_plan_overwrite_orientation_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.global_plan_overwrite_orientation)
}

// optional bool allow_init_with_backwards_motion = 5;
inline bool Trajectory::has_allow_init_with_backwards_motion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Trajectory::set_has_allow_init_with_backwards_motion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Trajectory::clear_has_allow_init_with_backwards_motion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Trajectory::clear_allow_init_with_backwards_motion() {
  allow_init_with_backwards_motion_ = false;
  clear_has_allow_init_with_backwards_motion();
}
inline bool Trajectory::allow_init_with_backwards_motion() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.allow_init_with_backwards_motion)
  return allow_init_with_backwards_motion_;
}
inline void Trajectory::set_allow_init_with_backwards_motion(bool value) {
  set_has_allow_init_with_backwards_motion();
  allow_init_with_backwards_motion_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.allow_init_with_backwards_motion)
}

// optional float global_plan_viapoint_sep = 6;
inline bool Trajectory::has_global_plan_viapoint_sep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Trajectory::set_has_global_plan_viapoint_sep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Trajectory::clear_has_global_plan_viapoint_sep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Trajectory::clear_global_plan_viapoint_sep() {
  global_plan_viapoint_sep_ = 0;
  clear_has_global_plan_viapoint_sep();
}
inline float Trajectory::global_plan_viapoint_sep() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.global_plan_viapoint_sep)
  return global_plan_viapoint_sep_;
}
inline void Trajectory::set_global_plan_viapoint_sep(float value) {
  set_has_global_plan_viapoint_sep();
  global_plan_viapoint_sep_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.global_plan_viapoint_sep)
}

// optional bool via_points_ordered = 7;
inline bool Trajectory::has_via_points_ordered() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Trajectory::set_has_via_points_ordered() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Trajectory::clear_has_via_points_ordered() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Trajectory::clear_via_points_ordered() {
  via_points_ordered_ = false;
  clear_has_via_points_ordered();
}
inline bool Trajectory::via_points_ordered() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.via_points_ordered)
  return via_points_ordered_;
}
inline void Trajectory::set_via_points_ordered(bool value) {
  set_has_via_points_ordered();
  via_points_ordered_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.via_points_ordered)
}

// optional float max_global_plan_lookahead_dist = 8;
inline bool Trajectory::has_max_global_plan_lookahead_dist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Trajectory::set_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Trajectory::clear_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Trajectory::clear_max_global_plan_lookahead_dist() {
  max_global_plan_lookahead_dist_ = 0;
  clear_has_max_global_plan_lookahead_dist();
}
inline float Trajectory::max_global_plan_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.max_global_plan_lookahead_dist)
  return max_global_plan_lookahead_dist_;
}
inline void Trajectory::set_max_global_plan_lookahead_dist(float value) {
  set_has_max_global_plan_lookahead_dist();
  max_global_plan_lookahead_dist_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.max_global_plan_lookahead_dist)
}

// optional bool exact_arc_length = 9;
inline bool Trajectory::has_exact_arc_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Trajectory::set_has_exact_arc_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Trajectory::clear_has_exact_arc_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Trajectory::clear_exact_arc_length() {
  exact_arc_length_ = false;
  clear_has_exact_arc_length();
}
inline bool Trajectory::exact_arc_length() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.exact_arc_length)
  return exact_arc_length_;
}
inline void Trajectory::set_exact_arc_length(bool value) {
  set_has_exact_arc_length();
  exact_arc_length_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.exact_arc_length)
}

// optional float force_reinit_new_goal_dist = 10;
inline bool Trajectory::has_force_reinit_new_goal_dist() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Trajectory::set_has_force_reinit_new_goal_dist() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Trajectory::clear_has_force_reinit_new_goal_dist() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Trajectory::clear_force_reinit_new_goal_dist() {
  force_reinit_new_goal_dist_ = 0;
  clear_has_force_reinit_new_goal_dist();
}
inline float Trajectory::force_reinit_new_goal_dist() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.force_reinit_new_goal_dist)
  return force_reinit_new_goal_dist_;
}
inline void Trajectory::set_force_reinit_new_goal_dist(float value) {
  set_has_force_reinit_new_goal_dist();
  force_reinit_new_goal_dist_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.force_reinit_new_goal_dist)
}

// optional int64 feasibility_check_no_poses = 11;
inline bool Trajectory::has_feasibility_check_no_poses() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Trajectory::set_has_feasibility_check_no_poses() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Trajectory::clear_has_feasibility_check_no_poses() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Trajectory::clear_feasibility_check_no_poses() {
  feasibility_check_no_poses_ = GOOGLE_LONGLONG(0);
  clear_has_feasibility_check_no_poses();
}
inline ::google::protobuf::int64 Trajectory::feasibility_check_no_poses() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.feasibility_check_no_poses)
  return feasibility_check_no_poses_;
}
inline void Trajectory::set_feasibility_check_no_poses(::google::protobuf::int64 value) {
  set_has_feasibility_check_no_poses();
  feasibility_check_no_poses_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.feasibility_check_no_poses)
}

// optional bool publish_feedback = 12;
inline bool Trajectory::has_publish_feedback() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Trajectory::set_has_publish_feedback() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Trajectory::clear_has_publish_feedback() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Trajectory::clear_publish_feedback() {
  publish_feedback_ = false;
  clear_has_publish_feedback();
}
inline bool Trajectory::publish_feedback() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.publish_feedback)
  return publish_feedback_;
}
inline void Trajectory::set_publish_feedback(bool value) {
  set_has_publish_feedback();
  publish_feedback_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.publish_feedback)
}

// optional int64 min_samples = 13;
inline bool Trajectory::has_min_samples() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Trajectory::set_has_min_samples() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Trajectory::clear_has_min_samples() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Trajectory::clear_min_samples() {
  min_samples_ = GOOGLE_LONGLONG(0);
  clear_has_min_samples();
}
inline ::google::protobuf::int64 Trajectory::min_samples() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.min_samples)
  return min_samples_;
}
inline void Trajectory::set_min_samples(::google::protobuf::int64 value) {
  set_has_min_samples();
  min_samples_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.min_samples)
}

// optional int64 max_samples = 14;
inline bool Trajectory::has_max_samples() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Trajectory::set_has_max_samples() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Trajectory::clear_has_max_samples() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Trajectory::clear_max_samples() {
  max_samples_ = GOOGLE_LONGLONG(0);
  clear_has_max_samples();
}
inline ::google::protobuf::int64 Trajectory::max_samples() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Trajectory.max_samples)
  return max_samples_;
}
inline void Trajectory::set_max_samples(::google::protobuf::int64 value) {
  set_has_max_samples();
  max_samples_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Trajectory.max_samples)
}

// -------------------------------------------------------------------

// FootprintModel

// optional .rrts.planning.local_planner.FootprintModel.FootprintType type = 1;
inline bool FootprintModel::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FootprintModel::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FootprintModel::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FootprintModel::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rrts::planning::local_planner::FootprintModel_FootprintType FootprintModel::type() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.type)
  return static_cast< ::rrts::planning::local_planner::FootprintModel_FootprintType >(type_);
}
inline void FootprintModel::set_type(::rrts::planning::local_planner::FootprintModel_FootprintType value) {
  assert(::rrts::planning::local_planner::FootprintModel_FootprintType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FootprintModel.type)
}

// optional double radius = 2;
inline bool FootprintModel::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FootprintModel::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FootprintModel::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FootprintModel::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double FootprintModel::radius() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.radius)
  return radius_;
}
inline void FootprintModel::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FootprintModel.radius)
}

// optional double front_offset = 3;
inline bool FootprintModel::has_front_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FootprintModel::set_has_front_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FootprintModel::clear_has_front_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FootprintModel::clear_front_offset() {
  front_offset_ = 0;
  clear_has_front_offset();
}
inline double FootprintModel::front_offset() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.front_offset)
  return front_offset_;
}
inline void FootprintModel::set_front_offset(double value) {
  set_has_front_offset();
  front_offset_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FootprintModel.front_offset)
}

// optional double front_radius = 4;
inline bool FootprintModel::has_front_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FootprintModel::set_has_front_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FootprintModel::clear_has_front_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FootprintModel::clear_front_radius() {
  front_radius_ = 0;
  clear_has_front_radius();
}
inline double FootprintModel::front_radius() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.front_radius)
  return front_radius_;
}
inline void FootprintModel::set_front_radius(double value) {
  set_has_front_radius();
  front_radius_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FootprintModel.front_radius)
}

// optional double rear_offset = 5;
inline bool FootprintModel::has_rear_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FootprintModel::set_has_rear_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FootprintModel::clear_has_rear_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FootprintModel::clear_rear_offset() {
  rear_offset_ = 0;
  clear_has_rear_offset();
}
inline double FootprintModel::rear_offset() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.rear_offset)
  return rear_offset_;
}
inline void FootprintModel::set_rear_offset(double value) {
  set_has_rear_offset();
  rear_offset_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FootprintModel.rear_offset)
}

// optional double rear_radius = 6;
inline bool FootprintModel::has_rear_radius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FootprintModel::set_has_rear_radius() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FootprintModel::clear_has_rear_radius() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FootprintModel::clear_rear_radius() {
  rear_radius_ = 0;
  clear_has_rear_radius();
}
inline double FootprintModel::rear_radius() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.rear_radius)
  return rear_radius_;
}
inline void FootprintModel::set_rear_radius(double value) {
  set_has_rear_radius();
  rear_radius_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.FootprintModel.rear_radius)
}

// repeated .rrts.planning.local_planner.Point2D robot_vertices = 7;
inline int FootprintModel::robot_vertices_size() const {
  return robot_vertices_.size();
}
inline void FootprintModel::clear_robot_vertices() {
  robot_vertices_.Clear();
}
inline const ::rrts::planning::local_planner::Point2D& FootprintModel::robot_vertices(int index) const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Get(index);
}
inline ::rrts::planning::local_planner::Point2D* FootprintModel::mutable_robot_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Mutable(index);
}
inline ::rrts::planning::local_planner::Point2D* FootprintModel::add_robot_vertices() {
  // @@protoc_insertion_point(field_add:rrts.planning.local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::Point2D >&
FootprintModel::robot_vertices() const {
  // @@protoc_insertion_point(field_list:rrts.planning.local_planner.FootprintModel.robot_vertices)
  return robot_vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::Point2D >*
FootprintModel::mutable_robot_vertices() {
  // @@protoc_insertion_point(field_mutable_list:rrts.planning.local_planner.FootprintModel.robot_vertices)
  return &robot_vertices_;
}

// -------------------------------------------------------------------

// Robot

// optional float max_vel_x = 1;
inline bool Robot::has_max_vel_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_max_vel_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_max_vel_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_max_vel_x() {
  max_vel_x_ = 0;
  clear_has_max_vel_x();
}
inline float Robot::max_vel_x() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.max_vel_x)
  return max_vel_x_;
}
inline void Robot::set_max_vel_x(float value) {
  set_has_max_vel_x();
  max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.max_vel_x)
}

// optional float max_vel_x_backwards = 2;
inline bool Robot::has_max_vel_x_backwards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_max_vel_x_backwards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_max_vel_x_backwards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_max_vel_x_backwards() {
  max_vel_x_backwards_ = 0;
  clear_has_max_vel_x_backwards();
}
inline float Robot::max_vel_x_backwards() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.max_vel_x_backwards)
  return max_vel_x_backwards_;
}
inline void Robot::set_max_vel_x_backwards(float value) {
  set_has_max_vel_x_backwards();
  max_vel_x_backwards_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.max_vel_x_backwards)
}

// optional float max_vel_y = 3;
inline bool Robot::has_max_vel_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Robot::set_has_max_vel_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Robot::clear_has_max_vel_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Robot::clear_max_vel_y() {
  max_vel_y_ = 0;
  clear_has_max_vel_y();
}
inline float Robot::max_vel_y() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.max_vel_y)
  return max_vel_y_;
}
inline void Robot::set_max_vel_y(float value) {
  set_has_max_vel_y();
  max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.max_vel_y)
}

// optional float max_vel_theta = 4;
inline bool Robot::has_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Robot::set_has_max_vel_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Robot::clear_has_max_vel_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Robot::clear_max_vel_theta() {
  max_vel_theta_ = 0;
  clear_has_max_vel_theta();
}
inline float Robot::max_vel_theta() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.max_vel_theta)
  return max_vel_theta_;
}
inline void Robot::set_max_vel_theta(float value) {
  set_has_max_vel_theta();
  max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.max_vel_theta)
}

// optional float acc_lim_x = 5;
inline bool Robot::has_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Robot::set_has_acc_lim_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Robot::clear_has_acc_lim_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Robot::clear_acc_lim_x() {
  acc_lim_x_ = 0;
  clear_has_acc_lim_x();
}
inline float Robot::acc_lim_x() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.acc_lim_x)
  return acc_lim_x_;
}
inline void Robot::set_acc_lim_x(float value) {
  set_has_acc_lim_x();
  acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.acc_lim_x)
}

// optional float acc_lim_y = 6;
inline bool Robot::has_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Robot::set_has_acc_lim_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Robot::clear_has_acc_lim_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Robot::clear_acc_lim_y() {
  acc_lim_y_ = 0;
  clear_has_acc_lim_y();
}
inline float Robot::acc_lim_y() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.acc_lim_y)
  return acc_lim_y_;
}
inline void Robot::set_acc_lim_y(float value) {
  set_has_acc_lim_y();
  acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.acc_lim_y)
}

// optional float acc_lim_theta = 7;
inline bool Robot::has_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Robot::set_has_acc_lim_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Robot::clear_has_acc_lim_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Robot::clear_acc_lim_theta() {
  acc_lim_theta_ = 0;
  clear_has_acc_lim_theta();
}
inline float Robot::acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.acc_lim_theta)
  return acc_lim_theta_;
}
inline void Robot::set_acc_lim_theta(float value) {
  set_has_acc_lim_theta();
  acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.acc_lim_theta)
}

// optional float min_turning_radius = 8;
inline bool Robot::has_min_turning_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Robot::set_has_min_turning_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Robot::clear_has_min_turning_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Robot::clear_min_turning_radius() {
  min_turning_radius_ = 0;
  clear_has_min_turning_radius();
}
inline float Robot::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.min_turning_radius)
  return min_turning_radius_;
}
inline void Robot::set_min_turning_radius(float value) {
  set_has_min_turning_radius();
  min_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.min_turning_radius)
}

// optional float wheelbase = 9;
inline bool Robot::has_wheelbase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Robot::set_has_wheelbase() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Robot::clear_has_wheelbase() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Robot::clear_wheelbase() {
  wheelbase_ = 0;
  clear_has_wheelbase();
}
inline float Robot::wheelbase() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.wheelbase)
  return wheelbase_;
}
inline void Robot::set_wheelbase(float value) {
  set_has_wheelbase();
  wheelbase_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.wheelbase)
}

// optional bool cmd_angle_instead_rotvel = 10;
inline bool Robot::has_cmd_angle_instead_rotvel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Robot::set_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Robot::clear_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Robot::clear_cmd_angle_instead_rotvel() {
  cmd_angle_instead_rotvel_ = false;
  clear_has_cmd_angle_instead_rotvel();
}
inline bool Robot::cmd_angle_instead_rotvel() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Robot.cmd_angle_instead_rotvel)
  return cmd_angle_instead_rotvel_;
}
inline void Robot::set_cmd_angle_instead_rotvel(bool value) {
  set_has_cmd_angle_instead_rotvel();
  cmd_angle_instead_rotvel_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Robot.cmd_angle_instead_rotvel)
}

// -------------------------------------------------------------------

// GoalTolerance

// optional float xy_goal_tolerance = 1;
inline bool GoalTolerance::has_xy_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalTolerance::set_has_xy_goal_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalTolerance::clear_has_xy_goal_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalTolerance::clear_xy_goal_tolerance() {
  xy_goal_tolerance_ = 0;
  clear_has_xy_goal_tolerance();
}
inline float GoalTolerance::xy_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.GoalTolerance.xy_goal_tolerance)
  return xy_goal_tolerance_;
}
inline void GoalTolerance::set_xy_goal_tolerance(float value) {
  set_has_xy_goal_tolerance();
  xy_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.GoalTolerance.xy_goal_tolerance)
}

// optional float yaw_goal_tolerance = 2;
inline bool GoalTolerance::has_yaw_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalTolerance::set_has_yaw_goal_tolerance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalTolerance::clear_has_yaw_goal_tolerance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalTolerance::clear_yaw_goal_tolerance() {
  yaw_goal_tolerance_ = 0;
  clear_has_yaw_goal_tolerance();
}
inline float GoalTolerance::yaw_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.GoalTolerance.yaw_goal_tolerance)
  return yaw_goal_tolerance_;
}
inline void GoalTolerance::set_yaw_goal_tolerance(float value) {
  set_has_yaw_goal_tolerance();
  yaw_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.GoalTolerance.yaw_goal_tolerance)
}

// optional bool free_goal_vel = 3;
inline bool GoalTolerance::has_free_goal_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalTolerance::set_has_free_goal_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalTolerance::clear_has_free_goal_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalTolerance::clear_free_goal_vel() {
  free_goal_vel_ = false;
  clear_has_free_goal_vel();
}
inline bool GoalTolerance::free_goal_vel() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.GoalTolerance.free_goal_vel)
  return free_goal_vel_;
}
inline void GoalTolerance::set_free_goal_vel(bool value) {
  set_has_free_goal_vel();
  free_goal_vel_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.GoalTolerance.free_goal_vel)
}

// -------------------------------------------------------------------

// Obstacles

// optional float min_obstacle_dist = 1;
inline bool Obstacles::has_min_obstacle_dist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacles::set_has_min_obstacle_dist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacles::clear_has_min_obstacle_dist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacles::clear_min_obstacle_dist() {
  min_obstacle_dist_ = 0;
  clear_has_min_obstacle_dist();
}
inline float Obstacles::min_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.min_obstacle_dist)
  return min_obstacle_dist_;
}
inline void Obstacles::set_min_obstacle_dist(float value) {
  set_has_min_obstacle_dist();
  min_obstacle_dist_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.min_obstacle_dist)
}

// optional float inflation_dist = 2;
inline bool Obstacles::has_inflation_dist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacles::set_has_inflation_dist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacles::clear_has_inflation_dist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacles::clear_inflation_dist() {
  inflation_dist_ = 0;
  clear_has_inflation_dist();
}
inline float Obstacles::inflation_dist() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.inflation_dist)
  return inflation_dist_;
}
inline void Obstacles::set_inflation_dist(float value) {
  set_has_inflation_dist();
  inflation_dist_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.inflation_dist)
}

// optional bool include_costmap_obstacles = 3;
inline bool Obstacles::has_include_costmap_obstacles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacles::set_has_include_costmap_obstacles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacles::clear_has_include_costmap_obstacles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacles::clear_include_costmap_obstacles() {
  include_costmap_obstacles_ = false;
  clear_has_include_costmap_obstacles();
}
inline bool Obstacles::include_costmap_obstacles() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.include_costmap_obstacles)
  return include_costmap_obstacles_;
}
inline void Obstacles::set_include_costmap_obstacles(bool value) {
  set_has_include_costmap_obstacles();
  include_costmap_obstacles_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.include_costmap_obstacles)
}

// optional float costmap_obstacles_behind_robot_dist = 4;
inline bool Obstacles::has_costmap_obstacles_behind_robot_dist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacles::set_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacles::clear_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacles::clear_costmap_obstacles_behind_robot_dist() {
  costmap_obstacles_behind_robot_dist_ = 0;
  clear_has_costmap_obstacles_behind_robot_dist();
}
inline float Obstacles::costmap_obstacles_behind_robot_dist() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
  return costmap_obstacles_behind_robot_dist_;
}
inline void Obstacles::set_costmap_obstacles_behind_robot_dist(float value) {
  set_has_costmap_obstacles_behind_robot_dist();
  costmap_obstacles_behind_robot_dist_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
}

// optional float obstacle_poses_affected = 5;
inline bool Obstacles::has_obstacle_poses_affected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacles::set_has_obstacle_poses_affected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacles::clear_has_obstacle_poses_affected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacles::clear_obstacle_poses_affected() {
  obstacle_poses_affected_ = 0;
  clear_has_obstacle_poses_affected();
}
inline float Obstacles::obstacle_poses_affected() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.obstacle_poses_affected)
  return obstacle_poses_affected_;
}
inline void Obstacles::set_obstacle_poses_affected(float value) {
  set_has_obstacle_poses_affected();
  obstacle_poses_affected_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.obstacle_poses_affected)
}

// optional bool legacy_obstacle_association = 6;
inline bool Obstacles::has_legacy_obstacle_association() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacles::set_has_legacy_obstacle_association() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacles::clear_has_legacy_obstacle_association() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacles::clear_legacy_obstacle_association() {
  legacy_obstacle_association_ = false;
  clear_has_legacy_obstacle_association();
}
inline bool Obstacles::legacy_obstacle_association() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.legacy_obstacle_association)
  return legacy_obstacle_association_;
}
inline void Obstacles::set_legacy_obstacle_association(bool value) {
  set_has_legacy_obstacle_association();
  legacy_obstacle_association_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.legacy_obstacle_association)
}

// optional float obstacle_association_cutoff_factor = 7;
inline bool Obstacles::has_obstacle_association_cutoff_factor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Obstacles::set_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Obstacles::clear_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Obstacles::clear_obstacle_association_cutoff_factor() {
  obstacle_association_cutoff_factor_ = 0;
  clear_has_obstacle_association_cutoff_factor();
}
inline float Obstacles::obstacle_association_cutoff_factor() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.obstacle_association_cutoff_factor)
  return obstacle_association_cutoff_factor_;
}
inline void Obstacles::set_obstacle_association_cutoff_factor(float value) {
  set_has_obstacle_association_cutoff_factor();
  obstacle_association_cutoff_factor_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.obstacle_association_cutoff_factor)
}

// optional float obstacle_association_force_inclusion_factor = 8;
inline bool Obstacles::has_obstacle_association_force_inclusion_factor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Obstacles::set_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Obstacles::clear_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Obstacles::clear_obstacle_association_force_inclusion_factor() {
  obstacle_association_force_inclusion_factor_ = 0;
  clear_has_obstacle_association_force_inclusion_factor();
}
inline float Obstacles::obstacle_association_force_inclusion_factor() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.obstacle_association_force_inclusion_factor)
  return obstacle_association_force_inclusion_factor_;
}
inline void Obstacles::set_obstacle_association_force_inclusion_factor(float value) {
  set_has_obstacle_association_force_inclusion_factor();
  obstacle_association_force_inclusion_factor_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.obstacle_association_force_inclusion_factor)
}

// optional string costmap_converter_plugin = 9;
inline bool Obstacles::has_costmap_converter_plugin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Obstacles::set_has_costmap_converter_plugin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Obstacles::clear_has_costmap_converter_plugin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Obstacles::clear_costmap_converter_plugin() {
  if (costmap_converter_plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costmap_converter_plugin_->clear();
  }
  clear_has_costmap_converter_plugin();
}
inline const ::std::string& Obstacles::costmap_converter_plugin() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.costmap_converter_plugin)
  return *costmap_converter_plugin_;
}
inline void Obstacles::set_costmap_converter_plugin(const ::std::string& value) {
  set_has_costmap_converter_plugin();
  if (costmap_converter_plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costmap_converter_plugin_ = new ::std::string;
  }
  costmap_converter_plugin_->assign(value);
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.costmap_converter_plugin)
}
inline void Obstacles::set_costmap_converter_plugin(const char* value) {
  set_has_costmap_converter_plugin();
  if (costmap_converter_plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costmap_converter_plugin_ = new ::std::string;
  }
  costmap_converter_plugin_->assign(value);
  // @@protoc_insertion_point(field_set_char:rrts.planning.local_planner.Obstacles.costmap_converter_plugin)
}
inline void Obstacles::set_costmap_converter_plugin(const char* value, size_t size) {
  set_has_costmap_converter_plugin();
  if (costmap_converter_plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costmap_converter_plugin_ = new ::std::string;
  }
  costmap_converter_plugin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rrts.planning.local_planner.Obstacles.costmap_converter_plugin)
}
inline ::std::string* Obstacles::mutable_costmap_converter_plugin() {
  set_has_costmap_converter_plugin();
  if (costmap_converter_plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costmap_converter_plugin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Obstacles.costmap_converter_plugin)
  return costmap_converter_plugin_;
}
inline ::std::string* Obstacles::release_costmap_converter_plugin() {
  clear_has_costmap_converter_plugin();
  if (costmap_converter_plugin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = costmap_converter_plugin_;
    costmap_converter_plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Obstacles::set_allocated_costmap_converter_plugin(::std::string* costmap_converter_plugin) {
  if (costmap_converter_plugin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete costmap_converter_plugin_;
  }
  if (costmap_converter_plugin) {
    set_has_costmap_converter_plugin();
    costmap_converter_plugin_ = costmap_converter_plugin;
  } else {
    clear_has_costmap_converter_plugin();
    costmap_converter_plugin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Obstacles.costmap_converter_plugin)
}

// optional bool costmap_converter_spin_thread = 10;
inline bool Obstacles::has_costmap_converter_spin_thread() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Obstacles::set_has_costmap_converter_spin_thread() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Obstacles::clear_has_costmap_converter_spin_thread() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Obstacles::clear_costmap_converter_spin_thread() {
  costmap_converter_spin_thread_ = false;
  clear_has_costmap_converter_spin_thread();
}
inline bool Obstacles::costmap_converter_spin_thread() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.costmap_converter_spin_thread)
  return costmap_converter_spin_thread_;
}
inline void Obstacles::set_costmap_converter_spin_thread(bool value) {
  set_has_costmap_converter_spin_thread();
  costmap_converter_spin_thread_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.costmap_converter_spin_thread)
}

// optional float costmap_converter_rate = 11;
inline bool Obstacles::has_costmap_converter_rate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Obstacles::set_has_costmap_converter_rate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Obstacles::clear_has_costmap_converter_rate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Obstacles::clear_costmap_converter_rate() {
  costmap_converter_rate_ = 0;
  clear_has_costmap_converter_rate();
}
inline float Obstacles::costmap_converter_rate() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Obstacles.costmap_converter_rate)
  return costmap_converter_rate_;
}
inline void Obstacles::set_costmap_converter_rate(float value) {
  set_has_costmap_converter_rate();
  costmap_converter_rate_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Obstacles.costmap_converter_rate)
}

// -------------------------------------------------------------------

// Optimization

// optional int32 no_inner_iterations = 1;
inline bool Optimization::has_no_inner_iterations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Optimization::set_has_no_inner_iterations() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Optimization::clear_has_no_inner_iterations() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Optimization::clear_no_inner_iterations() {
  no_inner_iterations_ = 0;
  clear_has_no_inner_iterations();
}
inline ::google::protobuf::int32 Optimization::no_inner_iterations() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.no_inner_iterations)
  return no_inner_iterations_;
}
inline void Optimization::set_no_inner_iterations(::google::protobuf::int32 value) {
  set_has_no_inner_iterations();
  no_inner_iterations_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.no_inner_iterations)
}

// optional int32 no_outer_iterations = 2;
inline bool Optimization::has_no_outer_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Optimization::set_has_no_outer_iterations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Optimization::clear_has_no_outer_iterations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Optimization::clear_no_outer_iterations() {
  no_outer_iterations_ = 0;
  clear_has_no_outer_iterations();
}
inline ::google::protobuf::int32 Optimization::no_outer_iterations() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.no_outer_iterations)
  return no_outer_iterations_;
}
inline void Optimization::set_no_outer_iterations(::google::protobuf::int32 value) {
  set_has_no_outer_iterations();
  no_outer_iterations_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.no_outer_iterations)
}

// optional bool optimization_activate = 3;
inline bool Optimization::has_optimization_activate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Optimization::set_has_optimization_activate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Optimization::clear_has_optimization_activate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Optimization::clear_optimization_activate() {
  optimization_activate_ = false;
  clear_has_optimization_activate();
}
inline bool Optimization::optimization_activate() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.optimization_activate)
  return optimization_activate_;
}
inline void Optimization::set_optimization_activate(bool value) {
  set_has_optimization_activate();
  optimization_activate_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.optimization_activate)
}

// optional bool optimization_verbose = 4;
inline bool Optimization::has_optimization_verbose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Optimization::set_has_optimization_verbose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Optimization::clear_has_optimization_verbose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Optimization::clear_optimization_verbose() {
  optimization_verbose_ = false;
  clear_has_optimization_verbose();
}
inline bool Optimization::optimization_verbose() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.optimization_verbose)
  return optimization_verbose_;
}
inline void Optimization::set_optimization_verbose(bool value) {
  set_has_optimization_verbose();
  optimization_verbose_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.optimization_verbose)
}

// optional float penalty_epsilon = 5;
inline bool Optimization::has_penalty_epsilon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Optimization::set_has_penalty_epsilon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Optimization::clear_has_penalty_epsilon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Optimization::clear_penalty_epsilon() {
  penalty_epsilon_ = 0;
  clear_has_penalty_epsilon();
}
inline float Optimization::penalty_epsilon() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.penalty_epsilon)
  return penalty_epsilon_;
}
inline void Optimization::set_penalty_epsilon(float value) {
  set_has_penalty_epsilon();
  penalty_epsilon_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.penalty_epsilon)
}

// optional float weight_max_vel_x = 6;
inline bool Optimization::has_weight_max_vel_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Optimization::set_has_weight_max_vel_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Optimization::clear_has_weight_max_vel_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Optimization::clear_weight_max_vel_x() {
  weight_max_vel_x_ = 0;
  clear_has_weight_max_vel_x();
}
inline float Optimization::weight_max_vel_x() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_max_vel_x)
  return weight_max_vel_x_;
}
inline void Optimization::set_weight_max_vel_x(float value) {
  set_has_weight_max_vel_x();
  weight_max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_max_vel_x)
}

// optional float weight_max_vel_y = 7;
inline bool Optimization::has_weight_max_vel_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Optimization::set_has_weight_max_vel_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Optimization::clear_has_weight_max_vel_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Optimization::clear_weight_max_vel_y() {
  weight_max_vel_y_ = 0;
  clear_has_weight_max_vel_y();
}
inline float Optimization::weight_max_vel_y() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_max_vel_y)
  return weight_max_vel_y_;
}
inline void Optimization::set_weight_max_vel_y(float value) {
  set_has_weight_max_vel_y();
  weight_max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_max_vel_y)
}

// optional float weight_max_vel_theta = 8;
inline bool Optimization::has_weight_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Optimization::set_has_weight_max_vel_theta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Optimization::clear_has_weight_max_vel_theta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Optimization::clear_weight_max_vel_theta() {
  weight_max_vel_theta_ = 0;
  clear_has_weight_max_vel_theta();
}
inline float Optimization::weight_max_vel_theta() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_max_vel_theta)
  return weight_max_vel_theta_;
}
inline void Optimization::set_weight_max_vel_theta(float value) {
  set_has_weight_max_vel_theta();
  weight_max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_max_vel_theta)
}

// optional float weight_acc_lim_x = 9;
inline bool Optimization::has_weight_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Optimization::clear_has_weight_acc_lim_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Optimization::clear_weight_acc_lim_x() {
  weight_acc_lim_x_ = 0;
  clear_has_weight_acc_lim_x();
}
inline float Optimization::weight_acc_lim_x() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_acc_lim_x)
  return weight_acc_lim_x_;
}
inline void Optimization::set_weight_acc_lim_x(float value) {
  set_has_weight_acc_lim_x();
  weight_acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_acc_lim_x)
}

// optional float weight_acc_lim_y = 10;
inline bool Optimization::has_weight_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Optimization::clear_has_weight_acc_lim_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Optimization::clear_weight_acc_lim_y() {
  weight_acc_lim_y_ = 0;
  clear_has_weight_acc_lim_y();
}
inline float Optimization::weight_acc_lim_y() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_acc_lim_y)
  return weight_acc_lim_y_;
}
inline void Optimization::set_weight_acc_lim_y(float value) {
  set_has_weight_acc_lim_y();
  weight_acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_acc_lim_y)
}

// optional float weight_acc_lim_thet = 11;
inline bool Optimization::has_weight_acc_lim_thet() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_thet() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Optimization::clear_has_weight_acc_lim_thet() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Optimization::clear_weight_acc_lim_thet() {
  weight_acc_lim_thet_ = 0;
  clear_has_weight_acc_lim_thet();
}
inline float Optimization::weight_acc_lim_thet() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_acc_lim_thet)
  return weight_acc_lim_thet_;
}
inline void Optimization::set_weight_acc_lim_thet(float value) {
  set_has_weight_acc_lim_thet();
  weight_acc_lim_thet_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_acc_lim_thet)
}

// optional float weight_kinematics_nh = 12;
inline bool Optimization::has_weight_kinematics_nh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Optimization::set_has_weight_kinematics_nh() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Optimization::clear_has_weight_kinematics_nh() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Optimization::clear_weight_kinematics_nh() {
  weight_kinematics_nh_ = 0;
  clear_has_weight_kinematics_nh();
}
inline float Optimization::weight_kinematics_nh() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_kinematics_nh)
  return weight_kinematics_nh_;
}
inline void Optimization::set_weight_kinematics_nh(float value) {
  set_has_weight_kinematics_nh();
  weight_kinematics_nh_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_kinematics_nh)
}

// optional float weight_kinematics_forward_drive = 13;
inline bool Optimization::has_weight_kinematics_forward_drive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Optimization::set_has_weight_kinematics_forward_drive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Optimization::clear_has_weight_kinematics_forward_drive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Optimization::clear_weight_kinematics_forward_drive() {
  weight_kinematics_forward_drive_ = 0;
  clear_has_weight_kinematics_forward_drive();
}
inline float Optimization::weight_kinematics_forward_drive() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_kinematics_forward_drive)
  return weight_kinematics_forward_drive_;
}
inline void Optimization::set_weight_kinematics_forward_drive(float value) {
  set_has_weight_kinematics_forward_drive();
  weight_kinematics_forward_drive_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_kinematics_forward_drive)
}

// optional float weight_kinematics_turning_radius = 14;
inline bool Optimization::has_weight_kinematics_turning_radius() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Optimization::set_has_weight_kinematics_turning_radius() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Optimization::clear_has_weight_kinematics_turning_radius() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Optimization::clear_weight_kinematics_turning_radius() {
  weight_kinematics_turning_radius_ = 0;
  clear_has_weight_kinematics_turning_radius();
}
inline float Optimization::weight_kinematics_turning_radius() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_kinematics_turning_radius)
  return weight_kinematics_turning_radius_;
}
inline void Optimization::set_weight_kinematics_turning_radius(float value) {
  set_has_weight_kinematics_turning_radius();
  weight_kinematics_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_kinematics_turning_radius)
}

// optional float weight_optimaltime = 15;
inline bool Optimization::has_weight_optimaltime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Optimization::set_has_weight_optimaltime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Optimization::clear_has_weight_optimaltime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Optimization::clear_weight_optimaltime() {
  weight_optimaltime_ = 0;
  clear_has_weight_optimaltime();
}
inline float Optimization::weight_optimaltime() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_optimaltime)
  return weight_optimaltime_;
}
inline void Optimization::set_weight_optimaltime(float value) {
  set_has_weight_optimaltime();
  weight_optimaltime_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_optimaltime)
}

// optional float weight_obstacle = 16;
inline bool Optimization::has_weight_obstacle() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Optimization::set_has_weight_obstacle() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Optimization::clear_has_weight_obstacle() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Optimization::clear_weight_obstacle() {
  weight_obstacle_ = 0;
  clear_has_weight_obstacle();
}
inline float Optimization::weight_obstacle() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_obstacle)
  return weight_obstacle_;
}
inline void Optimization::set_weight_obstacle(float value) {
  set_has_weight_obstacle();
  weight_obstacle_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_obstacle)
}

// optional float weight_inflation = 17;
inline bool Optimization::has_weight_inflation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Optimization::set_has_weight_inflation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Optimization::clear_has_weight_inflation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Optimization::clear_weight_inflation() {
  weight_inflation_ = 0;
  clear_has_weight_inflation();
}
inline float Optimization::weight_inflation() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_inflation)
  return weight_inflation_;
}
inline void Optimization::set_weight_inflation(float value) {
  set_has_weight_inflation();
  weight_inflation_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_inflation)
}

// optional float weight_dynamic_obstacle = 18;
inline bool Optimization::has_weight_dynamic_obstacle() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Optimization::set_has_weight_dynamic_obstacle() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Optimization::clear_has_weight_dynamic_obstacle() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Optimization::clear_weight_dynamic_obstacle() {
  weight_dynamic_obstacle_ = 0;
  clear_has_weight_dynamic_obstacle();
}
inline float Optimization::weight_dynamic_obstacle() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_dynamic_obstacle)
  return weight_dynamic_obstacle_;
}
inline void Optimization::set_weight_dynamic_obstacle(float value) {
  set_has_weight_dynamic_obstacle();
  weight_dynamic_obstacle_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_dynamic_obstacle)
}

// optional float weight_viapoint = 19;
inline bool Optimization::has_weight_viapoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Optimization::set_has_weight_viapoint() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Optimization::clear_has_weight_viapoint() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Optimization::clear_weight_viapoint() {
  weight_viapoint_ = 0;
  clear_has_weight_viapoint();
}
inline float Optimization::weight_viapoint() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_viapoint)
  return weight_viapoint_;
}
inline void Optimization::set_weight_viapoint(float value) {
  set_has_weight_viapoint();
  weight_viapoint_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_viapoint)
}

// optional float weight_adapt_factor = 20;
inline bool Optimization::has_weight_adapt_factor() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Optimization::set_has_weight_adapt_factor() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Optimization::clear_has_weight_adapt_factor() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Optimization::clear_weight_adapt_factor() {
  weight_adapt_factor_ = 0;
  clear_has_weight_adapt_factor();
}
inline float Optimization::weight_adapt_factor() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_adapt_factor)
  return weight_adapt_factor_;
}
inline void Optimization::set_weight_adapt_factor(float value) {
  set_has_weight_adapt_factor();
  weight_adapt_factor_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_adapt_factor)
}

// optional float weight_prefer_rotdir = 21;
inline bool Optimization::has_weight_prefer_rotdir() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Optimization::set_has_weight_prefer_rotdir() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Optimization::clear_has_weight_prefer_rotdir() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Optimization::clear_weight_prefer_rotdir() {
  weight_prefer_rotdir_ = 0;
  clear_has_weight_prefer_rotdir();
}
inline float Optimization::weight_prefer_rotdir() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_prefer_rotdir)
  return weight_prefer_rotdir_;
}
inline void Optimization::set_weight_prefer_rotdir(float value) {
  set_has_weight_prefer_rotdir();
  weight_prefer_rotdir_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_prefer_rotdir)
}

// optional float weight_acc_lim_theta = 22;
inline bool Optimization::has_weight_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_theta() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Optimization::clear_has_weight_acc_lim_theta() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Optimization::clear_weight_acc_lim_theta() {
  weight_acc_lim_theta_ = 0;
  clear_has_weight_acc_lim_theta();
}
inline float Optimization::weight_acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Optimization.weight_acc_lim_theta)
  return weight_acc_lim_theta_;
}
inline void Optimization::set_weight_acc_lim_theta(float value) {
  set_has_weight_acc_lim_theta();
  weight_acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Optimization.weight_acc_lim_theta)
}

// -------------------------------------------------------------------

// HomotopyClassPlanner

// optional bool enable_homotopy_class_planning = 1;
inline bool HomotopyClassPlanner::has_enable_homotopy_class_planning() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HomotopyClassPlanner::set_has_enable_homotopy_class_planning() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HomotopyClassPlanner::clear_has_enable_homotopy_class_planning() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HomotopyClassPlanner::clear_enable_homotopy_class_planning() {
  enable_homotopy_class_planning_ = false;
  clear_has_enable_homotopy_class_planning();
}
inline bool HomotopyClassPlanner::enable_homotopy_class_planning() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
  return enable_homotopy_class_planning_;
}
inline void HomotopyClassPlanner::set_enable_homotopy_class_planning(bool value) {
  set_has_enable_homotopy_class_planning();
  enable_homotopy_class_planning_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.enable_homotopy_class_planning)
}

// optional bool enable_multithreading = 2;
inline bool HomotopyClassPlanner::has_enable_multithreading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HomotopyClassPlanner::set_has_enable_multithreading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HomotopyClassPlanner::clear_has_enable_multithreading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HomotopyClassPlanner::clear_enable_multithreading() {
  enable_multithreading_ = false;
  clear_has_enable_multithreading();
}
inline bool HomotopyClassPlanner::enable_multithreading() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.enable_multithreading)
  return enable_multithreading_;
}
inline void HomotopyClassPlanner::set_enable_multithreading(bool value) {
  set_has_enable_multithreading();
  enable_multithreading_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.enable_multithreading)
}

// optional bool simple_exploration = 3;
inline bool HomotopyClassPlanner::has_simple_exploration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HomotopyClassPlanner::set_has_simple_exploration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HomotopyClassPlanner::clear_has_simple_exploration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HomotopyClassPlanner::clear_simple_exploration() {
  simple_exploration_ = false;
  clear_has_simple_exploration();
}
inline bool HomotopyClassPlanner::simple_exploration() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.simple_exploration)
  return simple_exploration_;
}
inline void HomotopyClassPlanner::set_simple_exploration(bool value) {
  set_has_simple_exploration();
  simple_exploration_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.simple_exploration)
}

// optional int32 max_number_classes = 4;
inline bool HomotopyClassPlanner::has_max_number_classes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HomotopyClassPlanner::set_has_max_number_classes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HomotopyClassPlanner::clear_has_max_number_classes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HomotopyClassPlanner::clear_max_number_classes() {
  max_number_classes_ = 0;
  clear_has_max_number_classes();
}
inline ::google::protobuf::int32 HomotopyClassPlanner::max_number_classes() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.max_number_classes)
  return max_number_classes_;
}
inline void HomotopyClassPlanner::set_max_number_classes(::google::protobuf::int32 value) {
  set_has_max_number_classes();
  max_number_classes_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.max_number_classes)
}

// optional float selection_obst_cost_scale = 5;
inline bool HomotopyClassPlanner::has_selection_obst_cost_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_obst_cost_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HomotopyClassPlanner::clear_has_selection_obst_cost_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HomotopyClassPlanner::clear_selection_obst_cost_scale() {
  selection_obst_cost_scale_ = 0;
  clear_has_selection_obst_cost_scale();
}
inline float HomotopyClassPlanner::selection_obst_cost_scale() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
  return selection_obst_cost_scale_;
}
inline void HomotopyClassPlanner::set_selection_obst_cost_scale(float value) {
  set_has_selection_obst_cost_scale();
  selection_obst_cost_scale_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.selection_obst_cost_scale)
}

// optional float selection_prefer_initial_plan = 6;
inline bool HomotopyClassPlanner::has_selection_prefer_initial_plan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_prefer_initial_plan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HomotopyClassPlanner::clear_has_selection_prefer_initial_plan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HomotopyClassPlanner::clear_selection_prefer_initial_plan() {
  selection_prefer_initial_plan_ = 0;
  clear_has_selection_prefer_initial_plan();
}
inline float HomotopyClassPlanner::selection_prefer_initial_plan() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
  return selection_prefer_initial_plan_;
}
inline void HomotopyClassPlanner::set_selection_prefer_initial_plan(float value) {
  set_has_selection_prefer_initial_plan();
  selection_prefer_initial_plan_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.selection_prefer_initial_plan)
}

// optional float selection_viapoint_cost_scale = 7;
inline bool HomotopyClassPlanner::has_selection_viapoint_cost_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_viapoint_cost_scale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HomotopyClassPlanner::clear_has_selection_viapoint_cost_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HomotopyClassPlanner::clear_selection_viapoint_cost_scale() {
  selection_viapoint_cost_scale_ = 0;
  clear_has_selection_viapoint_cost_scale();
}
inline float HomotopyClassPlanner::selection_viapoint_cost_scale() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
  return selection_viapoint_cost_scale_;
}
inline void HomotopyClassPlanner::set_selection_viapoint_cost_scale(float value) {
  set_has_selection_viapoint_cost_scale();
  selection_viapoint_cost_scale_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.selection_viapoint_cost_scale)
}

// optional float selection_cost_hysteresis = 8;
inline bool HomotopyClassPlanner::has_selection_cost_hysteresis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_cost_hysteresis() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HomotopyClassPlanner::clear_has_selection_cost_hysteresis() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HomotopyClassPlanner::clear_selection_cost_hysteresis() {
  selection_cost_hysteresis_ = 0;
  clear_has_selection_cost_hysteresis();
}
inline float HomotopyClassPlanner::selection_cost_hysteresis() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
  return selection_cost_hysteresis_;
}
inline void HomotopyClassPlanner::set_selection_cost_hysteresis(float value) {
  set_has_selection_cost_hysteresis();
  selection_cost_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.selection_cost_hysteresis)
}

// optional bool selection_alternative_time_cost = 9;
inline bool HomotopyClassPlanner::has_selection_alternative_time_cost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HomotopyClassPlanner::set_has_selection_alternative_time_cost() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HomotopyClassPlanner::clear_has_selection_alternative_time_cost() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HomotopyClassPlanner::clear_selection_alternative_time_cost() {
  selection_alternative_time_cost_ = false;
  clear_has_selection_alternative_time_cost();
}
inline bool HomotopyClassPlanner::selection_alternative_time_cost() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
  return selection_alternative_time_cost_;
}
inline void HomotopyClassPlanner::set_selection_alternative_time_cost(bool value) {
  set_has_selection_alternative_time_cost();
  selection_alternative_time_cost_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.selection_alternative_time_cost)
}

// optional int32 roadmap_graph_no_samples = 10;
inline bool HomotopyClassPlanner::has_roadmap_graph_no_samples() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HomotopyClassPlanner::set_has_roadmap_graph_no_samples() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HomotopyClassPlanner::clear_has_roadmap_graph_no_samples() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HomotopyClassPlanner::clear_roadmap_graph_no_samples() {
  roadmap_graph_no_samples_ = 0;
  clear_has_roadmap_graph_no_samples();
}
inline ::google::protobuf::int32 HomotopyClassPlanner::roadmap_graph_no_samples() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
  return roadmap_graph_no_samples_;
}
inline void HomotopyClassPlanner::set_roadmap_graph_no_samples(::google::protobuf::int32 value) {
  set_has_roadmap_graph_no_samples();
  roadmap_graph_no_samples_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.roadmap_graph_no_samples)
}

// optional int32 roadmap_graph_area_width = 11;
inline bool HomotopyClassPlanner::has_roadmap_graph_area_width() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HomotopyClassPlanner::set_has_roadmap_graph_area_width() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HomotopyClassPlanner::clear_has_roadmap_graph_area_width() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HomotopyClassPlanner::clear_roadmap_graph_area_width() {
  roadmap_graph_area_width_ = 0;
  clear_has_roadmap_graph_area_width();
}
inline ::google::protobuf::int32 HomotopyClassPlanner::roadmap_graph_area_width() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
  return roadmap_graph_area_width_;
}
inline void HomotopyClassPlanner::set_roadmap_graph_area_width(::google::protobuf::int32 value) {
  set_has_roadmap_graph_area_width();
  roadmap_graph_area_width_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.roadmap_graph_area_width)
}

// optional float roadmap_graph_area_length_scale = 12;
inline bool HomotopyClassPlanner::has_roadmap_graph_area_length_scale() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HomotopyClassPlanner::set_has_roadmap_graph_area_length_scale() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HomotopyClassPlanner::clear_has_roadmap_graph_area_length_scale() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HomotopyClassPlanner::clear_roadmap_graph_area_length_scale() {
  roadmap_graph_area_length_scale_ = 0;
  clear_has_roadmap_graph_area_length_scale();
}
inline float HomotopyClassPlanner::roadmap_graph_area_length_scale() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
  return roadmap_graph_area_length_scale_;
}
inline void HomotopyClassPlanner::set_roadmap_graph_area_length_scale(float value) {
  set_has_roadmap_graph_area_length_scale();
  roadmap_graph_area_length_scale_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.roadmap_graph_area_length_scale)
}

// optional float h_signature_prescaler = 13;
inline bool HomotopyClassPlanner::has_h_signature_prescaler() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HomotopyClassPlanner::set_has_h_signature_prescaler() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HomotopyClassPlanner::clear_has_h_signature_prescaler() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HomotopyClassPlanner::clear_h_signature_prescaler() {
  h_signature_prescaler_ = 0;
  clear_has_h_signature_prescaler();
}
inline float HomotopyClassPlanner::h_signature_prescaler() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.h_signature_prescaler)
  return h_signature_prescaler_;
}
inline void HomotopyClassPlanner::set_h_signature_prescaler(float value) {
  set_has_h_signature_prescaler();
  h_signature_prescaler_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.h_signature_prescaler)
}

// optional float h_signature_threshold = 14;
inline bool HomotopyClassPlanner::has_h_signature_threshold() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HomotopyClassPlanner::set_has_h_signature_threshold() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HomotopyClassPlanner::clear_has_h_signature_threshold() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HomotopyClassPlanner::clear_h_signature_threshold() {
  h_signature_threshold_ = 0;
  clear_has_h_signature_threshold();
}
inline float HomotopyClassPlanner::h_signature_threshold() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.h_signature_threshold)
  return h_signature_threshold_;
}
inline void HomotopyClassPlanner::set_h_signature_threshold(float value) {
  set_has_h_signature_threshold();
  h_signature_threshold_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.h_signature_threshold)
}

// optional float obstacle_keypoint_offset = 15;
inline bool HomotopyClassPlanner::has_obstacle_keypoint_offset() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void HomotopyClassPlanner::set_has_obstacle_keypoint_offset() {
  _has_bits_[0] |= 0x00004000u;
}
inline void HomotopyClassPlanner::clear_has_obstacle_keypoint_offset() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void HomotopyClassPlanner::clear_obstacle_keypoint_offset() {
  obstacle_keypoint_offset_ = 0;
  clear_has_obstacle_keypoint_offset();
}
inline float HomotopyClassPlanner::obstacle_keypoint_offset() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
  return obstacle_keypoint_offset_;
}
inline void HomotopyClassPlanner::set_obstacle_keypoint_offset(float value) {
  set_has_obstacle_keypoint_offset();
  obstacle_keypoint_offset_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.obstacle_keypoint_offset)
}

// optional float obstacle_heading_threshold = 16;
inline bool HomotopyClassPlanner::has_obstacle_heading_threshold() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void HomotopyClassPlanner::set_has_obstacle_heading_threshold() {
  _has_bits_[0] |= 0x00008000u;
}
inline void HomotopyClassPlanner::clear_has_obstacle_heading_threshold() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void HomotopyClassPlanner::clear_obstacle_heading_threshold() {
  obstacle_heading_threshold_ = 0;
  clear_has_obstacle_heading_threshold();
}
inline float HomotopyClassPlanner::obstacle_heading_threshold() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
  return obstacle_heading_threshold_;
}
inline void HomotopyClassPlanner::set_obstacle_heading_threshold(float value) {
  set_has_obstacle_heading_threshold();
  obstacle_heading_threshold_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.obstacle_heading_threshold)
}

// optional bool viapoints_all_candidates = 17;
inline bool HomotopyClassPlanner::has_viapoints_all_candidates() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void HomotopyClassPlanner::set_has_viapoints_all_candidates() {
  _has_bits_[0] |= 0x00010000u;
}
inline void HomotopyClassPlanner::clear_has_viapoints_all_candidates() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void HomotopyClassPlanner::clear_viapoints_all_candidates() {
  viapoints_all_candidates_ = false;
  clear_has_viapoints_all_candidates();
}
inline bool HomotopyClassPlanner::viapoints_all_candidates() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.viapoints_all_candidates)
  return viapoints_all_candidates_;
}
inline void HomotopyClassPlanner::set_viapoints_all_candidates(bool value) {
  set_has_viapoints_all_candidates();
  viapoints_all_candidates_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.viapoints_all_candidates)
}

// optional bool visualize_hc_graph = 18;
inline bool HomotopyClassPlanner::has_visualize_hc_graph() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void HomotopyClassPlanner::set_has_visualize_hc_graph() {
  _has_bits_[0] |= 0x00020000u;
}
inline void HomotopyClassPlanner::clear_has_visualize_hc_graph() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void HomotopyClassPlanner::clear_visualize_hc_graph() {
  visualize_hc_graph_ = false;
  clear_has_visualize_hc_graph();
}
inline bool HomotopyClassPlanner::visualize_hc_graph() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.HomotopyClassPlanner.visualize_hc_graph)
  return visualize_hc_graph_;
}
inline void HomotopyClassPlanner::set_visualize_hc_graph(bool value) {
  set_has_visualize_hc_graph();
  visualize_hc_graph_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.HomotopyClassPlanner.visualize_hc_graph)
}

// -------------------------------------------------------------------

// Recovery

// optional bool shrink_horizon_min_duration = 1;
inline bool Recovery::has_shrink_horizon_min_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Recovery::set_has_shrink_horizon_min_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Recovery::clear_has_shrink_horizon_min_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Recovery::clear_shrink_horizon_min_duration() {
  shrink_horizon_min_duration_ = false;
  clear_has_shrink_horizon_min_duration();
}
inline bool Recovery::shrink_horizon_min_duration() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.shrink_horizon_min_duration)
  return shrink_horizon_min_duration_;
}
inline void Recovery::set_shrink_horizon_min_duration(bool value) {
  set_has_shrink_horizon_min_duration();
  shrink_horizon_min_duration_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.shrink_horizon_min_duration)
}

// optional bool oscillation_recovery = 2;
inline bool Recovery::has_oscillation_recovery() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Recovery::set_has_oscillation_recovery() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Recovery::clear_has_oscillation_recovery() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Recovery::clear_oscillation_recovery() {
  oscillation_recovery_ = false;
  clear_has_oscillation_recovery();
}
inline bool Recovery::oscillation_recovery() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.oscillation_recovery)
  return oscillation_recovery_;
}
inline void Recovery::set_oscillation_recovery(bool value) {
  set_has_oscillation_recovery();
  oscillation_recovery_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.oscillation_recovery)
}

// optional bool shrink_horizon_backup = 3;
inline bool Recovery::has_shrink_horizon_backup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Recovery::set_has_shrink_horizon_backup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Recovery::clear_has_shrink_horizon_backup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Recovery::clear_shrink_horizon_backup() {
  shrink_horizon_backup_ = false;
  clear_has_shrink_horizon_backup();
}
inline bool Recovery::shrink_horizon_backup() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.shrink_horizon_backup)
  return shrink_horizon_backup_;
}
inline void Recovery::set_shrink_horizon_backup(bool value) {
  set_has_shrink_horizon_backup();
  shrink_horizon_backup_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.shrink_horizon_backup)
}

// optional double oscillation_v_eps = 4;
inline bool Recovery::has_oscillation_v_eps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Recovery::set_has_oscillation_v_eps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Recovery::clear_has_oscillation_v_eps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Recovery::clear_oscillation_v_eps() {
  oscillation_v_eps_ = 0;
  clear_has_oscillation_v_eps();
}
inline double Recovery::oscillation_v_eps() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.oscillation_v_eps)
  return oscillation_v_eps_;
}
inline void Recovery::set_oscillation_v_eps(double value) {
  set_has_oscillation_v_eps();
  oscillation_v_eps_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.oscillation_v_eps)
}

// optional double oscillation_omega_eps = 5;
inline bool Recovery::has_oscillation_omega_eps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Recovery::set_has_oscillation_omega_eps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Recovery::clear_has_oscillation_omega_eps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Recovery::clear_oscillation_omega_eps() {
  oscillation_omega_eps_ = 0;
  clear_has_oscillation_omega_eps();
}
inline double Recovery::oscillation_omega_eps() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.oscillation_omega_eps)
  return oscillation_omega_eps_;
}
inline void Recovery::set_oscillation_omega_eps(double value) {
  set_has_oscillation_omega_eps();
  oscillation_omega_eps_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.oscillation_omega_eps)
}

// optional double oscillation_recovery_min_duration = 6;
inline bool Recovery::has_oscillation_recovery_min_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Recovery::set_has_oscillation_recovery_min_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Recovery::clear_has_oscillation_recovery_min_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Recovery::clear_oscillation_recovery_min_duration() {
  oscillation_recovery_min_duration_ = 0;
  clear_has_oscillation_recovery_min_duration();
}
inline double Recovery::oscillation_recovery_min_duration() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.oscillation_recovery_min_duration)
  return oscillation_recovery_min_duration_;
}
inline void Recovery::set_oscillation_recovery_min_duration(double value) {
  set_has_oscillation_recovery_min_duration();
  oscillation_recovery_min_duration_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.oscillation_recovery_min_duration)
}

// optional double oscillation_filter_duration = 7;
inline bool Recovery::has_oscillation_filter_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Recovery::set_has_oscillation_filter_duration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Recovery::clear_has_oscillation_filter_duration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Recovery::clear_oscillation_filter_duration() {
  oscillation_filter_duration_ = 0;
  clear_has_oscillation_filter_duration();
}
inline double Recovery::oscillation_filter_duration() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Recovery.oscillation_filter_duration)
  return oscillation_filter_duration_;
}
inline void Recovery::set_oscillation_filter_duration(double value) {
  set_has_oscillation_filter_duration();
  oscillation_filter_duration_ = value;
  // @@protoc_insertion_point(field_set:rrts.planning.local_planner.Recovery.oscillation_filter_duration)
}

// -------------------------------------------------------------------

// Config

// optional .rrts.planning.local_planner.FrameID opt_frame = 1;
inline bool Config::has_opt_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_opt_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_opt_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_opt_frame() {
  if (opt_frame_ != NULL) opt_frame_->::rrts::planning::local_planner::FrameID::Clear();
  clear_has_opt_frame();
}
inline const ::rrts::planning::local_planner::FrameID& Config::opt_frame() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.opt_frame)
  return opt_frame_ != NULL ? *opt_frame_ : *default_instance_->opt_frame_;
}
inline ::rrts::planning::local_planner::FrameID* Config::mutable_opt_frame() {
  set_has_opt_frame();
  if (opt_frame_ == NULL) opt_frame_ = new ::rrts::planning::local_planner::FrameID;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.opt_frame)
  return opt_frame_;
}
inline ::rrts::planning::local_planner::FrameID* Config::release_opt_frame() {
  clear_has_opt_frame();
  ::rrts::planning::local_planner::FrameID* temp = opt_frame_;
  opt_frame_ = NULL;
  return temp;
}
inline void Config::set_allocated_opt_frame(::rrts::planning::local_planner::FrameID* opt_frame) {
  delete opt_frame_;
  opt_frame_ = opt_frame;
  if (opt_frame) {
    set_has_opt_frame();
  } else {
    clear_has_opt_frame();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.opt_frame)
}

// optional .rrts.planning.local_planner.Trajectory trajectory_opt = 2;
inline bool Config::has_trajectory_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_trajectory_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_trajectory_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_trajectory_opt() {
  if (trajectory_opt_ != NULL) trajectory_opt_->::rrts::planning::local_planner::Trajectory::Clear();
  clear_has_trajectory_opt();
}
inline const ::rrts::planning::local_planner::Trajectory& Config::trajectory_opt() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.trajectory_opt)
  return trajectory_opt_ != NULL ? *trajectory_opt_ : *default_instance_->trajectory_opt_;
}
inline ::rrts::planning::local_planner::Trajectory* Config::mutable_trajectory_opt() {
  set_has_trajectory_opt();
  if (trajectory_opt_ == NULL) trajectory_opt_ = new ::rrts::planning::local_planner::Trajectory;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.trajectory_opt)
  return trajectory_opt_;
}
inline ::rrts::planning::local_planner::Trajectory* Config::release_trajectory_opt() {
  clear_has_trajectory_opt();
  ::rrts::planning::local_planner::Trajectory* temp = trajectory_opt_;
  trajectory_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_trajectory_opt(::rrts::planning::local_planner::Trajectory* trajectory_opt) {
  delete trajectory_opt_;
  trajectory_opt_ = trajectory_opt;
  if (trajectory_opt) {
    set_has_trajectory_opt();
  } else {
    clear_has_trajectory_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.trajectory_opt)
}

// optional .rrts.planning.local_planner.Robot kinematics_opt = 3;
inline bool Config::has_kinematics_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_kinematics_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_kinematics_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_kinematics_opt() {
  if (kinematics_opt_ != NULL) kinematics_opt_->::rrts::planning::local_planner::Robot::Clear();
  clear_has_kinematics_opt();
}
inline const ::rrts::planning::local_planner::Robot& Config::kinematics_opt() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.kinematics_opt)
  return kinematics_opt_ != NULL ? *kinematics_opt_ : *default_instance_->kinematics_opt_;
}
inline ::rrts::planning::local_planner::Robot* Config::mutable_kinematics_opt() {
  set_has_kinematics_opt();
  if (kinematics_opt_ == NULL) kinematics_opt_ = new ::rrts::planning::local_planner::Robot;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.kinematics_opt)
  return kinematics_opt_;
}
inline ::rrts::planning::local_planner::Robot* Config::release_kinematics_opt() {
  clear_has_kinematics_opt();
  ::rrts::planning::local_planner::Robot* temp = kinematics_opt_;
  kinematics_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_kinematics_opt(::rrts::planning::local_planner::Robot* kinematics_opt) {
  delete kinematics_opt_;
  kinematics_opt_ = kinematics_opt;
  if (kinematics_opt) {
    set_has_kinematics_opt();
  } else {
    clear_has_kinematics_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.kinematics_opt)
}

// optional .rrts.planning.local_planner.GoalTolerance tolerance_opt = 4;
inline bool Config::has_tolerance_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_tolerance_opt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_tolerance_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_tolerance_opt() {
  if (tolerance_opt_ != NULL) tolerance_opt_->::rrts::planning::local_planner::GoalTolerance::Clear();
  clear_has_tolerance_opt();
}
inline const ::rrts::planning::local_planner::GoalTolerance& Config::tolerance_opt() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.tolerance_opt)
  return tolerance_opt_ != NULL ? *tolerance_opt_ : *default_instance_->tolerance_opt_;
}
inline ::rrts::planning::local_planner::GoalTolerance* Config::mutable_tolerance_opt() {
  set_has_tolerance_opt();
  if (tolerance_opt_ == NULL) tolerance_opt_ = new ::rrts::planning::local_planner::GoalTolerance;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.tolerance_opt)
  return tolerance_opt_;
}
inline ::rrts::planning::local_planner::GoalTolerance* Config::release_tolerance_opt() {
  clear_has_tolerance_opt();
  ::rrts::planning::local_planner::GoalTolerance* temp = tolerance_opt_;
  tolerance_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_tolerance_opt(::rrts::planning::local_planner::GoalTolerance* tolerance_opt) {
  delete tolerance_opt_;
  tolerance_opt_ = tolerance_opt;
  if (tolerance_opt) {
    set_has_tolerance_opt();
  } else {
    clear_has_tolerance_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.tolerance_opt)
}

// optional .rrts.planning.local_planner.Obstacles obstacles_opt = 5;
inline bool Config::has_obstacles_opt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_obstacles_opt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_obstacles_opt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_obstacles_opt() {
  if (obstacles_opt_ != NULL) obstacles_opt_->::rrts::planning::local_planner::Obstacles::Clear();
  clear_has_obstacles_opt();
}
inline const ::rrts::planning::local_planner::Obstacles& Config::obstacles_opt() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.obstacles_opt)
  return obstacles_opt_ != NULL ? *obstacles_opt_ : *default_instance_->obstacles_opt_;
}
inline ::rrts::planning::local_planner::Obstacles* Config::mutable_obstacles_opt() {
  set_has_obstacles_opt();
  if (obstacles_opt_ == NULL) obstacles_opt_ = new ::rrts::planning::local_planner::Obstacles;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.obstacles_opt)
  return obstacles_opt_;
}
inline ::rrts::planning::local_planner::Obstacles* Config::release_obstacles_opt() {
  clear_has_obstacles_opt();
  ::rrts::planning::local_planner::Obstacles* temp = obstacles_opt_;
  obstacles_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_obstacles_opt(::rrts::planning::local_planner::Obstacles* obstacles_opt) {
  delete obstacles_opt_;
  obstacles_opt_ = obstacles_opt;
  if (obstacles_opt) {
    set_has_obstacles_opt();
  } else {
    clear_has_obstacles_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.obstacles_opt)
}

// optional .rrts.planning.local_planner.Optimization optimize_info = 6;
inline bool Config::has_optimize_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_optimize_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_optimize_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_optimize_info() {
  if (optimize_info_ != NULL) optimize_info_->::rrts::planning::local_planner::Optimization::Clear();
  clear_has_optimize_info();
}
inline const ::rrts::planning::local_planner::Optimization& Config::optimize_info() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.optimize_info)
  return optimize_info_ != NULL ? *optimize_info_ : *default_instance_->optimize_info_;
}
inline ::rrts::planning::local_planner::Optimization* Config::mutable_optimize_info() {
  set_has_optimize_info();
  if (optimize_info_ == NULL) optimize_info_ = new ::rrts::planning::local_planner::Optimization;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.optimize_info)
  return optimize_info_;
}
inline ::rrts::planning::local_planner::Optimization* Config::release_optimize_info() {
  clear_has_optimize_info();
  ::rrts::planning::local_planner::Optimization* temp = optimize_info_;
  optimize_info_ = NULL;
  return temp;
}
inline void Config::set_allocated_optimize_info(::rrts::planning::local_planner::Optimization* optimize_info) {
  delete optimize_info_;
  optimize_info_ = optimize_info;
  if (optimize_info) {
    set_has_optimize_info();
  } else {
    clear_has_optimize_info();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.optimize_info)
}

// optional .rrts.planning.local_planner.HomotopyClassPlanner hcp_opt = 7;
inline bool Config::has_hcp_opt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Config::set_has_hcp_opt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Config::clear_has_hcp_opt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Config::clear_hcp_opt() {
  if (hcp_opt_ != NULL) hcp_opt_->::rrts::planning::local_planner::HomotopyClassPlanner::Clear();
  clear_has_hcp_opt();
}
inline const ::rrts::planning::local_planner::HomotopyClassPlanner& Config::hcp_opt() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.hcp_opt)
  return hcp_opt_ != NULL ? *hcp_opt_ : *default_instance_->hcp_opt_;
}
inline ::rrts::planning::local_planner::HomotopyClassPlanner* Config::mutable_hcp_opt() {
  set_has_hcp_opt();
  if (hcp_opt_ == NULL) hcp_opt_ = new ::rrts::planning::local_planner::HomotopyClassPlanner;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.hcp_opt)
  return hcp_opt_;
}
inline ::rrts::planning::local_planner::HomotopyClassPlanner* Config::release_hcp_opt() {
  clear_has_hcp_opt();
  ::rrts::planning::local_planner::HomotopyClassPlanner* temp = hcp_opt_;
  hcp_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_hcp_opt(::rrts::planning::local_planner::HomotopyClassPlanner* hcp_opt) {
  delete hcp_opt_;
  hcp_opt_ = hcp_opt;
  if (hcp_opt) {
    set_has_hcp_opt();
  } else {
    clear_has_hcp_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.hcp_opt)
}

// repeated .rrts.planning.local_planner.FootprintModel robot_type = 8;
inline int Config::robot_type_size() const {
  return robot_type_.size();
}
inline void Config::clear_robot_type() {
  robot_type_.Clear();
}
inline const ::rrts::planning::local_planner::FootprintModel& Config::robot_type(int index) const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.robot_type)
  return robot_type_.Get(index);
}
inline ::rrts::planning::local_planner::FootprintModel* Config::mutable_robot_type(int index) {
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.robot_type)
  return robot_type_.Mutable(index);
}
inline ::rrts::planning::local_planner::FootprintModel* Config::add_robot_type() {
  // @@protoc_insertion_point(field_add:rrts.planning.local_planner.Config.robot_type)
  return robot_type_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::FootprintModel >&
Config::robot_type() const {
  // @@protoc_insertion_point(field_list:rrts.planning.local_planner.Config.robot_type)
  return robot_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::rrts::planning::local_planner::FootprintModel >*
Config::mutable_robot_type() {
  // @@protoc_insertion_point(field_mutable_list:rrts.planning.local_planner.Config.robot_type)
  return &robot_type_;
}

// optional .rrts.planning.local_planner.Recovery recovery_info = 9;
inline bool Config::has_recovery_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Config::set_has_recovery_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Config::clear_has_recovery_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Config::clear_recovery_info() {
  if (recovery_info_ != NULL) recovery_info_->::rrts::planning::local_planner::Recovery::Clear();
  clear_has_recovery_info();
}
inline const ::rrts::planning::local_planner::Recovery& Config::recovery_info() const {
  // @@protoc_insertion_point(field_get:rrts.planning.local_planner.Config.recovery_info)
  return recovery_info_ != NULL ? *recovery_info_ : *default_instance_->recovery_info_;
}
inline ::rrts::planning::local_planner::Recovery* Config::mutable_recovery_info() {
  set_has_recovery_info();
  if (recovery_info_ == NULL) recovery_info_ = new ::rrts::planning::local_planner::Recovery;
  // @@protoc_insertion_point(field_mutable:rrts.planning.local_planner.Config.recovery_info)
  return recovery_info_;
}
inline ::rrts::planning::local_planner::Recovery* Config::release_recovery_info() {
  clear_has_recovery_info();
  ::rrts::planning::local_planner::Recovery* temp = recovery_info_;
  recovery_info_ = NULL;
  return temp;
}
inline void Config::set_allocated_recovery_info(::rrts::planning::local_planner::Recovery* recovery_info) {
  delete recovery_info_;
  recovery_info_ = recovery_info;
  if (recovery_info) {
    set_has_recovery_info();
  } else {
    clear_has_recovery_info();
  }
  // @@protoc_insertion_point(field_set_allocated:rrts.planning.local_planner.Config.recovery_info)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace local_planner
}  // namespace planning
}  // namespace rrts

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::rrts::planning::local_planner::FootprintModel_FootprintType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rrts::planning::local_planner::FootprintModel_FootprintType>() {
  return ::rrts::planning::local_planner::FootprintModel_FootprintType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_timed_5felastic_5fband_2eproto__INCLUDED
